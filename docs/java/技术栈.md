# 一、Java

## Ⅰ Java基础

### 1. Java简介

Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。

#### 1.1 Java的三个体系

- **Java SE（Java Platform，Standard Edition）**

         Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition提供基础。

- **Java EE（Java Platform，Enterprise Edition）**

         Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。

- **Java ME（Java Platform，Micro Edition）**

         Java ME以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。

#### 1.2 Java 的主要特性

简单、面向对象、分布式、健壮、安全、体系结构中立、可移植、解释型、高性能、多线程、动态。

### 2. Java基础语法

#### 2.1 基础语法

- **大小写敏感**：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。
- **类名**：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。
- **方法名**：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。
- **源文件名**：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。
- **主方法入口**：所有的Java 程序由**public static void main(String args[])**方法开始执行。

#### 2.2 标识符

Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。

- 所有的标识符都应该以字母（A-Z或者a-z），美元符（$），或者下划线（_）开始，如$salary、\_value
- 首字符之后可以是任何字符的组合
- 关键字不能用作标识符
- 标识符是大小写敏感的

#### 2.3 数组

数组是储存在堆上的对象，可以保存多个同类型变量，这些变量类型既可以存储基本数据类型，也可以存储引用数据类型。

**一维数组**

```java
int[] a；     定义了一个int类型的数组a；
int a[];      定义了一个int类型的a数组；
//推荐使用第一种定义方式。
```

**数组初始化**就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。Java中的数组必须先初始化后使用。

```java
//动态初始化：只指定长度，由系统给出初始化值
int[] array = new int[4];

//静态初始化：给出初始化值，由系统决定长度
int[] array = new int[]{1, 2, 3, 4};
//可简写成
int[] array = {1, 2, 3, 4};
```

- **默认初始化：**数组是引用类型，它的元素相当于类的成员变量，因此数组分配空间后，每个元素也被按照成员变量的规则被隐士初始化。

**二维数组**

```java
int[][] arr = new int[3][2];
//定义了一个二维数组arr
//这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]
//每个一维数组有2个元素，可以通过arr[m][n]来获取,表示获取第m+1个一维数组的第n+1个元素
```

#### 2.4枚举

Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。

### 3. Java数据类型

#### 3.1 基本数据类型

Java语言内置八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，一种布尔类型。

| 类型    | 最小值       | 最大值            | 默认值 | 字节数 | 说明                             |
| ------- | ------------ | ----------------- | ------ | ------ | -------------------------------- |
| byte    | -128（-2^7） | 127（2^7-1）      | 0      | 1      | 有符号的，以二进制补码表示的整数 |
| short   | -2^15        | 2^15 - 1          | 0      | 2      | 有符号的以二进制补码表示的整数   |
| int     | -2^31        | 2^31 - 1          | 0      | 4      | 有符号的以二进制补码表示的整数   |
| long    | -2^63        | 2^63 -1           | 0L     | 8      | 有符号的以二进制补码表示的整数   |
| float   | 2^-149       | 2^128-1           | 0.0f   | 4      | 单精度、符合IEEE 754标准的浮点数 |
| double  | 2^1074       | 2^1024-1          | 0.0d   | 8      | 双精度、符合IEEE 754标准的浮点数 |
| boolean |              |                   | false  |        | 表示一位的信息                   |
| char    | '\u0000' (0) | '\uffff' (65,535) |        | 2      | 一个单一的16位Unicode字符        |

- 浮点数的默认类型为double类型，不能用来表示精确的值，如货币。但float在储存大型浮点数组的时候可节省内存空间。
- [Primitive Data Types](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)

#### 3.2 引用数据类型

Java为每种基本类型都提供了对应的封装类型，分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean。引用类型是一种对象类型,它的值是指向内存空间的引用，就是地址。

- 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，变量一旦声明后，类型就不能被改变了。
- 基本数据类型的变量是存储在栈内存中，而引用类型变量存储在栈内存中，保存的是实际对象在堆内存中的地址，实际对象中保存这内容。
- 对象、String、数组都是引用数据类型。
- 所有引用类型的默认值都是null。
- 一个引用变量可以用来引用任何与之兼容的类型。

#### 3.3 Number类

在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java语言为每一个内置数据类型提供了对应的包装类。所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类Number的子类。

![](https://7n.w3cschool.cn/attachments/image/20160401/1459506097805010.jpg)

**Math类**

Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。

Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。

#### 3.4 自动拆装箱

> Java 从 Jdk1.5 开始引入自动装箱和拆箱,使得基本数据类型与引用类型之间相互转换变得简单。

- **自动装箱**：Java自动将原始类型转化为引用类型的过程，自动装箱时编译器会调用valueOf()方法,将原始类型转化为对象类型。
- **自动拆箱**：Java自动将引用类型转化为原始类型的过程，自动拆箱时编译器会调用intValue(),doubleValue()这类的方法将对象转换成原始类型值。

**主要的发生情况**

一是赋值时:

```java
Integer a = 3; //自动装箱
int b = a; //自动拆箱
```

二是方法调用：

```java
public Integer query(Integer a){
   return a;
}
query(3); //自动装箱
int result = query(3); //自动拆箱
```

**带来的问题**

- **程序性能**

由于装箱会隐式地创建对象创建，因此千万不要在一个循环中进行自动装箱的操作，下面就是一个循环中进行自动装箱的例子，会额外创建多余的对象,增加GC的压力,影响程序的性能。

```java
Integer sum = 0;
 for(int i=0; i<1000; i++){
   sum+=i;
}
```

- **空指针异常**

```java
Object obj = null;
int i = (Integer)obj;
```

#### 3.5 对象比较(缓存池问题)

```java
Integer a = 120;
int b= 120;
Integer c = 120;
Integer d = new Integer(120);
System.out.println(a == b);   //true    t1
System.out.println(a == c);   //true    t2
System.out.println(a == d);   //false   t3

Integer e = 128;
Integer f = 128;
System.out.println(e == f);   //false   t4

//使用Java Decompiler工具反编译class文件：
Integer integer1 = Integer.valueOf(120);
byte b = 120;
Integer integer2 = Integer.valueOf(120);
Integer integer3 = new Integer(120);
System.out.println((integer1.intValue() == b));
System.out.println((integer1 == integer2));
System.out.println((integer1 == integer3));

Integer integer4 = Integer.valueOf(128);
Integer integer5 = Integer.valueOf(128);
System.out.println((integer4 == integer5));

```

1. t1产生的原因是编译器编译时会调用intValue()自动的将a进行了拆箱，结果肯定是true;
2. t3结果无论如何都不会相等的，因为new Integer(120)构造器会创建新的对象。
3. 对于t2和t4，查看jdk的源码：

```java
public static Integer valueOf(int i) {
    assert IntegerCache.high >= 127;
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

       发现在 Java 8 中，Integer 缓存池的大小默认为 -128\~127，对于-128~127之间的值会取缓存中的引用,通过缓存经常请求的值而显著提高空间和时间性能。 这就能解释t2结果返回true，而t4由于128不在缓存区间内，编译器调用valueOf方法会重新创建新的对象，两个不同的对象返回false。

**基本类型对应的缓冲池**

- boolean values true and false
- all byte values
- short  and int values between -128 and 127
- char in the range \u0000 to \u007F

#### 3.6 类型转换

整型、实型(常量)、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。

**自动类型转换**

数字表示范围小的数据类型可以自动转换成范围大的数据类型。

```java
int i = 200;
long l = i;
```

从小类型到大类型可以自动完成。类型的大小关系如下图所示：

![](https://images2015.cnblogs.com/blog/892594/201602/892594-20160212163546964-613019656.jpg)

值得注意的是，自动转换也要小心数据溢出问题：

```java
int count = 100000000;
int price = 1999;
long totalPrice = count * price;

//编译没任何问题，但结果却输出的是负数，
//这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围。
//这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。

int count = 100000000;
int price = 1999;
long totalPrice = (long) count * price;
```

**向下转换**时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。

**强制类型转换**

```java
short s = 199;
int i = s;// 199

double d = 10.24;
long ll = (long) d;// 10

//以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况。

int ii = 300;
byte b = (byte)ii;
//300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。
```

**类型提升**

所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。

```java
long count = 100000000;
int price = 1999;
long totalPrice = price * count;

//price 为 int 型，count 为 long 型，运算结果为 long 型，运算结果正常，没有出现溢出的情况。
```

#### 3.7 参数传递

Java 的参数是以值传递的形式传入方法中，而不是引用传递。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。

- 基本类型作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的。

  ```java
  public class Test {
         public static void main(String[] args) {
             int n = 3;
            
             System.out.println("Before change, n = " + n);    
             //Before change, n = 3
            
             changeData(n);
             System.out.println("After changeData(n), n = " + n);
             //After changeData(n), n = 3
         }
     
         public static void changeData(int nn) {
             n = 10;
         }
  }
  ```

- 对象作为参数传递时，是把对象在内存中的地址拷贝了一份传给了参数。

  ```java
  public class Test1 {
      public static void main(String[] args) {
          StringBuffer sb = new StringBuffer("Hello ");
          System.out.println("Before change, sb = " + sb);
          //Before change, sb = Hello
         
          changeData(sb);
          System.out.println("After changeData(n), sb = " + sb);
          //After changeData(n), sb = Hi World!
      }
      public static void changeData(StringBuffer strBuf) {
          strBuf.append("World!");
      }
  }
 
  public class Test2 {
      public static void main(String[] args) {
          StringBuffer sb = new StringBuffer("Hello ");
          System.out.println("Before change, sb = " + sb);
          //Before change, sb = Hello
         
          changeData(sb);
          System.out.println("After changeData(n), sb = " + sb);
          //After changeData(n), sb = Hello
      }
      public static void changeData(StringBuffer strBuf) {
          strBuf = new StringBuffer("Hi ");
          strBuf.append("World!");
      }
  }
  ```

  [StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?](https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value)

### 4. Java变量类型

> 在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：

```java
//type identifier [ = value][, identifier [= value] ...] ;

int a, b, c;         // 声明三个int型整数：a、b、c。
int d = 3, e, f = 5; // 声明三个整数并赋予初值。
```

#### 4.1 局部变量

> 类的方法中的变量

- 局部变量声明在方法、构造方法或者语句块中；
- 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；
- 访问修饰符不能用于局部变量；
- 局部变量只在声明它的方法、构造方法或者语句块中可见；
- 局部变量是在栈上分配的;
- 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。

#### 4.2 实例变量

> 独立于方法之外的变量，不过没有 static 修饰。

- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；
- 当一个对象被实例化之后，每个实例变量的值就跟着确定；
- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；
- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；
- 实例变量可以声明在使用前或者使用后；
- 访问修饰符可以修饰实例变量；
- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
- 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。

#### 4.3 类变量

> 亦称静态变量，独立于方法之外的变量，用 static 修饰。

- 类变量也称为静态变量，在类中以static关键字声明，但必须在方法、构造方法和语句块之外；
- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝；
- 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变；
- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量；
- 静态变量在程序开始时创建，在程序结束时销毁；
- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型；
- 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化；
- 类变量被声明为public static final类型时，类变量名称必须使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致；
- 静态变量可以通过：*ClassName.VariableName*的方式访问。



### 5. Java修饰符

像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：

1. **访问控制修饰符 :** default, public , protected, private
2. **非访问控制修饰符 :** final, abstract, static，synchronized 和 volatile

#### 5.1 访问控制修饰符

**默认访问控制修饰符**

- 使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。
- 接口里的变量都隐式声明为public static final,而接口里的方法默认情况下访问权限为public。

**私有访问控制修饰符**

- 私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。
- 声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。
- Private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。

**公有访问修饰符：**

- 被声明为public的类、方法、构造方法和接口能够被任何其他类访问。
- 类所有的公有方法和变量都能被其子类继承。
- Java程序的main() 方法必须设置成公有的，否则，Java解释器将不能运行该类。

**受保护的访问修饰符**

- 被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问，也能被不同包中的子类访问。

#### 5.2 访问控制与继承

- 父类中声明为public的方法在子类中也必须为public。
- 父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。
- 父类中默认修饰符声明的方法，能够在子类中声明为private。
- 父类中声明为private的方法，不能够被继承。

#### 5.3 非访问修饰符

> 为了实现一些其他的功能，Java也提供了许多非访问修饰符。

**static修饰符**

static修饰符，用来创建类方法和类变量。

- **静态变量：**static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为static变量。
- **静态方法：**static关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。

**final修饰符**

用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

- **final变量：**
  1. final变量能被显式地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同的对象。
  2. 但是final对象里的数据可以被改变。也就是说final对象的引用不能改变，但是里面的值可以改变。
- **final方法：**
  1. 类中的Final方法可以被子类继承，但是不能被子类修改。
  2. 声明final方法的主要目的是防止该方法的内容被修改。
- **final类：**
  1. final类不能被继承，没有类能够继承final类的任何特性。

**abstract修饰符**

| 抽象类                                                       | 抽象方法                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 | 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成final和static。 |
| 一个类不能同时被abstract和final修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 | 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 |
| 抽象类可以包含抽象方法和非抽象方法。                         | 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 |

**synchronized修饰符**

该关键字声明的方法同一时间只能被一个线程访问。Synchronized修饰符可以应用于四个访问修饰符。

**volatile修饰符**

修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。

**transient修饰符**

序列化的对象包含被transient修饰的实例变量时，java虚拟机(JVM)跳过该特定的变量。

该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型:

```java
public transient int limit = 55;   // will not persist
public int b; // will persist

```



### 6. Java运算符

数学运算是计算机的最基本用途之一，作为一门计算机编程语言，Java也提供了一套丰富的运算符来操纵变量。

#### 6.1 算术运算符

| 加法 | 减法 | 乘法 | 除法 | 取模 | 自增 | 自减 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | -    | *    | /    | %    | ++   | --   |

#### 6.2 关系运算符

| 相等 | 不等 | 大于 | 小于 | 大于等于 | 小于等于 |
| ---- | ---- | ---- | ---- | -------- | -------- |
| ==   | !=   | >    | <    | \>=      | \<=      |

#### 6.3 位运算符

> 变量A的值为60和变量B的值为13：

| 操作符 | 描述                                                         | 例子                           |
| ------ | ------------------------------------------------------------ | ------------------------------ |
| ＆     | 按位与操作符，当且仅当两个操作数的某一位都非0时候结果的该位才为1。 | （A＆B），得到12，即0000 1100  |
| \|     | 按位或操作符，只要两个操作数的某一位有一个非0时候结果的该位就为1。 | （A \| B）得到61，即 0011 1101 |
| ^      | 按位异或操作符，两个操作数的某一位不相同时候结果的该位就为1。 | （A ^ B）得到49，即 0011 0001  |
|      | 按位补运算符翻转操作数的每一位。                             | （A）得到-60，即1100 0011    |
| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |
| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |
| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |

#### 6.4 逻辑运算符

| 与   | 或   | 非   |
| ---- | ---- | ---- |
| &&   | \|\| | !    |

#### 6.5 赋值运算符

`=`是最简单的赋值运算符，将右操作数的值赋给左侧操作数，还可以与算数运算符和位运算符结合使用。

#### 6.6 条件运算符

条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

```java
variable x = (expression) ? value if true : value if false
```

#### 6.7 instanceOf 运算符

instanceOf 用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。

```java
//( Object reference variable ) instanceOf  (class/interface type)

String name = 'James';
boolean result = name instanceOf String; // 由于name是Strine类型，所以返回真
```

如果被比较的对象兼容于右侧类型,该运算符仍然返回true。

```java
class Vehicle {}

public class Car extends Vehicle {
   public static void main(String args[]){
      Vehicle a = new Car();
      boolean result =  a instanceof Car;
      System.out.println( result);
   }
}
```

#### 6.8 运算符优先级

> 下表中的运算符优先级由上至下依次降低：

| 类别     | 操作符                                     | 关联性   |
| -------- | ------------------------------------------ | -------- |
| 后缀     | () [] . (点操作符)                         | 左到右   |
| 一元     | + + - ！                                 | 从右到左 |
| 乘性     | * /％                                      | 左到右   |
| 加性     | + -                                        | 左到右   |
| 移位     | >> >>>  <<                                 | 左到右   |
| 关系     | >> = << =                                  | 左到右   |
| 相等     | ==  !=                                     | 左到右   |
| 按位与   | ＆                                         | 左到右   |
| 按位异或 | ^                                          | 左到右   |
| 按位或   | \|                                         | 左到右   |
| 逻辑与   | &&                                         | 左到右   |
| 逻辑或   | \| \|                                      | 左到右   |
| 条件     | ？：                                       | 从右到左 |
| 赋值     | = + = - = * = / =％= >> = << =＆= ^ = \| = | 从右到左 |
| 逗号     | ，                                         | 左到右   |



### 7. Java String类

在 Java语言中有8种基本类型和一种比较特殊的类型`String`。由于`String`在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池（当然基础类型也有）。

#### 7.1 常量池

常量池就类似一个Java系统级别提供的缓存，指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。Java会确保一个字符串常量只有一个拷贝。

```java
String s1 = "Programming";
String s2 = new String("Programming");
String s3 = "Program" + "ming";
String s4 = new String(s2);
String s5 = "Programming";

System.out.println(s1 == s2);//false
System.out.println(s4 == s2);//false
System.out.println(s1 == s3);//true
System.out.println(s1 == s5);//true
System.out.println(s1 == s1.intern());//true

s2.intern();
System.out.println(s1 == s2);//false 没有将返回值赋值给s2

s2=s2.intern();
System.out.println(s1 == s2);//true

```

- s1和s3中的”Programming”都是字符串常量，它们在编译期就被确定了，所以s1==s3为true；而”Program”和”ming”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，JVM对此做了一个优化，s3也同样在编译期就被解析为一个字符串常量，所以s3也是常量池中 ”Programming”的一个引用。 所以我们得出s5==s1==s3
- 用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。所以有s2！=s4
- String对象的intern()方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用。

**补充：**存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个 方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用， 如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用。

#### 7.2 String是不可变的

String 是一个典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。

- 可以缓存Hash值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
- 常量池的需要：如果一个String对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。
- 线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

#### 7.3 equals() & ==

- String类已经重写过了equals方法，这对于String简单来说就是比较两字符串的Unicode序列是否相当，如果相等返回true。而==是比较两字符串的地址是否相同，也就是是否是同一个字符串的引用。
- 在符合数据类型中，则equals和==都是比较两对象的地址是否相同，除非重写equals，详见hashcode与equals的区别。

#### 7.4 Buffer&Builder

- StringBuffer和StringBuilder都实现了AbstractStringBuilder抽象类，拥有几乎一致对外提供的调用接口。
- 其底层在内存中的存储方式与String相同，都是以一个有序的字符序列（char类型的数组，JDK 9 以后是 byte）进行存储，不同点是StringBuffer/StringBuilder对象的值是可以改变的，并且值改变以后，对象引用不会发生改变。
- 两者对象在构造过程中，首先按照默认大小申请一个字符数组（这个大小是 16），由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容通过arraycopy复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。
- **在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的。**区别仅在于最终的方法是否加了 synchronized，即三者的执行效率上 StringBuilder > StringBuffer > String 。

**小结：**

1. String适用于少量的字符串操作的情况。
2. StringBuilder适用于单线程下在字符缓冲区进行大量操作的情况。
3. StringBuffer适用多线程下在字符缓冲区进行大量操作的情况。



### 8. Object方法

#### 8.1 概况

```java
public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class<?> getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException

```

#### 8.2 equals()

**等价关系**

```java
//自反性
x.equals(x); // true

//对称性
x.equals(y) == y.equals(x); // true

//传递性
if (x.equals(y) && y.equals(z))
    x.equals(z); // true;

//一致性，多次调用 equals() 方法结果不变
x.equals(y) == x.equals(y); // true

//与 null 的比较
//对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false
x.equals(null); // false;

```

**等价与相等**

- 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
- 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。

```java
public class EqualExample {

    private int x, y, z;
   
    @Override
    public boolean equals(Object o) {
        //检查是否为同一个对象的引用，如果是直接返回 true
        if (this == o) return true;
        //检查是否是同一个类型，如果不是，直接返回 false
        if (o == null || getClass() != o.getClass()) return false;

        //将 Object 对象进行转型
        EqualExample that = (EqualExample) o;

        //判断每个关键域是否相等
        if (x != that.x) return false;
        if (y != that.y) return false;
        return z == that.z;
    }
}

```

#### 8.3 hashCode()

- hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。
- 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。

#### 8.4 toString()

默认返回 Example@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。

#### 8.5 clone()

**cloneable**

clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。

**浅拷贝**

拷贝对象和原始对象的引用类型引用同一个对象。

**深拷贝**

拷贝对象和原始对象的引用类型引用不同对象。

**clone() 的替代方案**

使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。



## Ⅱ Java OOP

### 1. 面向对象（OOP）

面向对象的本质是以类的方式组织代码，以对象的方式组织数据。

**面向过程**中事物比较简单，可以用线性思维去解决（第一步做什么，接下来做什么...)，**面向对象**事物比较复杂，使用简单的线性思维无法解决。

- 面向过程和面向对象都是解决实际问题的一种思维方式
- 二者相辅相成，并不是对立的。解决复杂问题，通过面向对象可以方便我们从宏观上把握复杂的关系，便于我们分析整个系统；具体到微观操作，仍然使用面向过程方式来处理。

### 2. 类和对象

#### 2.1 类（Class)

类是具有共同属性的一组对象，是创建对象的模板或蓝图，是一个逻辑实体。

**接口 (Interface)**

接口就是比“抽象类”还要抽象的“抽象类”，可以更加规范对子类进行约束。（接口就是规范，定义一组规则）

**面向接口编程 vs 实现接口编程**

项目的具体需求是多变的，我们必须以不变应万变才能从容开发。

```java
public class TestInterface implements MyInterface{

    public void test(){
        System.out.println("TestInterface.test");
    }

    public static void main(String[] args) {

        MyInterface i=new TestInterface();

        i.test();
    }
}

interface A{
   
}

interface B{

}

//接口中只有常量、抽象方法，实现设计与实现的分离

interface MyInterface extends A,B{

    int NUM=100;
    //接口中上面语句等同于下面的语句，编译器添加 public static final
    public static final int NUM1=100;

    void test();
    //接口中，
    //void test() == public static void test()
}
```

- 子类通过implements来实现接口中的规范
- 接口不能创建实例，但可以用于声明引用变量类型
- 一个类实现了接口，必须实现该接口中的所有方法，且这些方法只能是public
- 接口支持多继承

**抽象类 （Abstract)**

> 抽象类只有声明，没有实现
>
> 抽象类是一种模板模式，抽象类为所有子类提供一个通用模板，子类可以拓展。
>
> 通过抽象类，我们可以严格的限制子类，使子类之间更加通用

```java
public class TestAbstract{
   
    public static void main(String[] args) {
        //Animal a=new Animal();  //错误: Animal是抽象的; 无法实例化

        Animal a=new Cat();
        a.breath();
        //a.voice();
    }
}

abstract class Animal{
    public abstract void voice();

    public void breath(){
        System.out.println("呼吸");
        //voice();
    }
}

class Cat extends Animal{
    public void voice(){
        System.out.println("喵喵喵");
        //breath();
    }
    //错误: Cat不是抽象的, 并且未覆盖Animal中的抽象方法voice()
}
 
```

**抽象类要点**

- 有抽象方法的类只能定义成抽象类
- 抽象类不能实例化，即不能用new来实例化抽象类
- 抽象类可以包含属性、方法、构造器，但只能用来被子类调用
- 抽象类只能用于继承
- 抽象方法必须被子类实现

#### 2.2 管理

为何使用**Java包** （Package）:

1. 解决类之间的重名问题
2. 为了方便管理：合适的类位于合适的包名

值得注意 的是，com.gao和com.gao.car,这两个包没有包含关系，是完全独立的。（只是逻辑上看似后者是前者的一部分）

** JDK中常用包**

- **java.lang**（language)

  包含一些Java语言的核心类，如String，Math，Integer，System和Thread，提供常用功能

- **java.awt**

  包含抽象窗口工具集（abstract window toolkits）的多个类，这些类用来创建和管理程序的GUI

- **java.net**

  包含执行网络相关的操作类

- **java.io**

  包含能提供多种IO操作的类

- **java.util**

  包含一些实用的工具类，如定义系统特性，使用日期等

#### 2.3 包含

一个Java的类中包含了字段、方法、构造函数、代码块、嵌套类和接口六个部分。

```java
class Student{
    String name;
    int age;
}
//每个编译单元（文件）都只能有一个public类.
//这表示，每个编译单元都有单一的公共接口，用public类来表现。
public class TestClass{

    public static void main(String[] args) {

        //通过加载器 Class Loader加载Student类，将类的信息存放在方法区
        Student stu=new Student();
        stu.name="enosh";
        stu.age=20;

        //"anshun"、20均是常量，存放到方法区中的常量池
        //而堆中对象的属性则存放对应的地址

        String str="enosh";
        System.out.println(str==stu.name);
        //结果为true，即str与name指向同一个内存地址
    }
}
```

##### 2.3.1 类的属性

> 属性：field，或者叫做成员变量

1. 属性用于定义该类或改对象包含的数据或者说静态属性。
2. 属性的作用范围是整个类体。
3. 在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认值初始化。

**类的变量类型**

- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
- **类变量**    ：类变量也声明在类中，方法体之外，但必须声明为static类型。



##### 2.3.2 类的方法

> 在java中的方法类似函数，用于暴露对象的行为。

**方法的优点**

- 代码可重用性
- 代码优化

**方法的重载 （Overload）**

> 方法的重载是指一个类中可以定义有相同的名字，但参数不同的多个方法。调用时，会根据不同的参数表选择对应的方法。和普通方法一样，构造函数也可以重载。

两同三不同:

- 同一类，同一个方法名
- 参数表不同（类型、个数、顺序）

**方法的重写 （Override）**

- 子类中可以根据需要对基类中继承的方法进行重写
- 从写方法和被重写方法具有相同方法名、参数列表和返回类型
- 重写方法不能使用比被重写方法更严格的访问权限（由于多态）



##### 2.3.3 构造方法

> 构造方法又称构造器，用于构建该类的实例

**Constructor是一种特殊的方法：**

- 通过new关键字调用
- 构造器虽然有返回值，但不能自定义返回值，返回类型是本类
- 如果我们没有定义构造器，则系统将会自动定义一个无参构造函数（如果已经添加构造器，则编译器不会添加）
- 构造器的方法名必须与类名一致

```java
public class TestConstructor{

    public static void main(String[] args) {
       
        //Point p=new Point();  //错误: 无法将类 Point中的构造器 Point应用到给定类型;
        Point p=new Point(3.14,3.14);
    }
}

class Point{

    private double x,y;

    public Point(double x, double y){
        this.x=x;
        this.y=y;
    }
}
```



#### 2.4 对象（Object)

**2.4.1 引用类型**

- Java语言中除了基本类型之外的变量类型都称之为引用类型
- Java中的对象通过引用对其进行操作

**2.4.2 this**

> 隐式参数 : 普通方法中默认传入一个参数，即this。
>
> 类初始化存储于方法区，所有该类对象共用这一份代码，调用时传入this，以确定哪个对象

- 普通方法中：this总是指向调用该方法的对象
- 构造方法中：this总是指向正要初始化的对象
- this不能用于static方法（static方法不传递this参数）

```java
class Student{
    String name;
    int id;

    public Student(){

    }

    public Student(String name){
        this();  //通过this调用其它方法
        this.name=name;
        //this();  //错误: 对this的调用必须是构造器中的第一个语句
    }

    public void study(/*Student this*/){   //传递隐式的参数this
        this.name="anshun";
        System.out.println(name+"学习");
    }

}
```

**2.4.3 static**

> 区分类的变量和对象的变量，static对象从属于类，创建对象时不会存储static成员。

在类中，用static声明的成员变量称之为静态成员变量，或类属性、类变量
- 它为该类的公共变量，属于类，被类的所有实例共享，在类被载入时被显示初始化
- 对该类的所有对象来说，static成员变量只有一份，被该类所有对象共享
- static变量存储于方法区中

用static声明的方法称作**静态方法**
- 不需要对象就可以直接调用
- 在调用该方法时，不会将对象的引用传递给它，所以在static方法中不可访问非static的成员，而非static的成员可以访问和调用static成员。

**静态初始化块**

- 如果希望加载后，对整个类进行某些初始化操作，可以使用static初始化块
- 是类初始化时执行，不是创建对象时
- 静态初始化块不能访问非static成员
- 执行顺序：上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块。

**2.4.4 Final**

- **修饰变量：**常量，只能初始化一次，类似cpp中的constant
- **修饰方法：**改方法不可以被子类重写，但可以被重载
- **修饰类：**修饰的类不能有子类，即不能被继承，如Math、String

**2.4.5 内存结构**

待补充。。。



### 3. 三大基本特征

#### 3.1 继承（Inherit)

- 子类继承父类，可以得到除父类构造方法以外的全部属性和方法
- Java中只有单继承，但可以用接口实现多继承
- 如果一个类没有调用extends，则它的父类是java.lang.Object

**Object**

**Super**

> super是直接父类对象的引用，可以通过super来访问父类中被子类覆盖的方法或属性

- 普通方法：没有顺序限制，可以随便调用
- 构造方法：任何类的构造函数中，若是构造函数第一行没有显式的调用super(..)，那么Java默认都会调用super()作为父类的初始化函数。

**方法重写 （Override）**

- 子类中可以根据需要对基类中继承的方法进行重写
- 从写方法和被重写方法具有相同方法名、参数列表和返回类型
- 重写方法不能使用比被重写方法更严格的访问权限（由于多态）

**组合 **

`is-a` 关系使用继承，`has-a` 关系使用组合。



#### 3.2 封装 (Encapsulation )

**封装的作用及含义:**

- 隐藏对象内部的复杂性、只对外公开简单的接口，以便外界调用，从而提高系统的可拓展性、可维护性。

高聚合，低耦合:

- 高聚合就是类的内部数据操作细节自己完成，不允许外接干涉

**控制符**：

|           | 同一个类 | 同一个包 | 子类 | 所有类 |
| --------- | :------: | :------: | :--: | :----: |
| private   |    *     |          |      |        |
| default   |    *     |    *     |      |        |
| protected |    *     |    *     |  *   |        |
| public    |    *     |    *     |  *   |   *    |

#### 3.3 多态（polymorphism）

多态是OOP中的一个重要的特征，主要实现动态联编的，即程序的最终状态只有在执行过程中才被决定而非在编译期间。

**Java如何实现多态**

引用变量的两种类型：

- 编译时类型（模糊点，一般是一个父类）：由声明时的类型决定
- 执行时类型（运行时，具体是哪个子类就是那个子类）：由实际对象的类型决定
- 编译时，变量声明的什么类型就是什么类型，执行时，创建的什么类型对象就是什么类型

**多态的三个必要条件**

- 要有继承
- 要有方法重写
- 父类引用指向子类对象

```java
public class TestPolymorphism{

    //不使用多态
    public static void testCat(Cat a){
        a.voice();
    }

    public static void testDog(Dog a){
        a.voice();
    }

    public static void testPig(Pig a){
        a.voice();
    }

    //使用多态
    public static void testAnimal(Animal a){
        a.voice();
    }
   
    public static void main(String[] args) {
       
        testCat(new Cat());

        Animal a=new Cat();
        //编译时，a声明的是Animal类型，就会去Animal类中查找相应的成员
        //       如果没有改成员，则编译无法通过
        //执行过程中，a指向的是一个Cat类的实例对象，则a的类型就是Cat

        //a.play();//如法通过编译
        ((Cat)a).play();

        testAnimal(new Cat());  //父类的引用指向一个子类对象
        testAnimal(new Dog());
    }
}
class Animal{

    String str;

    public void voice(){
        System.out.println("普通动物叫声");
    }
}
class Cat extends Animal{

    public void voice(){
        System.out.println("喵喵喵");
    }

    public void play(){
        System.out.println("上树");
    }
}
class Dog extends Animal{

    public void voice(){
        System.out.println("汪汪汪");
    }
}
class Pig extends Animal{

    public void voice(){
        System.out.println("哼哼哼");
    }
}
```



## Ⅲ Java进阶

> 《Java核心技术 卷Ⅰ》

### 1. 注解

Java注解又称Annotation。注解不同于注释，可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。

#### 1.1 注解作用

- 生成描述性文件，甚至新的类定义；
- 减轻编写模板代码的负担；
- 使代码更加干净易懂；
- 将由编译器来测试和验证的格式，存储有关程序的额外信息。如@Override，可以让编译器检查子类中是否有重写父类中的方法。

#### 1.2 注解分类

**1.2.1 内建注解**

- @Override：表示当前的方法定义将覆盖超类中的方法；
- @Deprecated：为编译器将发出警告，因为注解@Deprecated解释的是被弃用的代码；
- @SuppressWarnings：关闭不当编译器警告信息；
- @SafeVarargs：参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的；
- @FunctionalInterface：**函数式接口**（就是一个具有一个方法的普通接口，如Runnable ）注解，这个是 Java 1.8 版本引入的新特性。

**1.2.2 元注解**

元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，应用到其它的注解上。

**@Target**

表示该注解可以用于什么地方，可能的ElementType参数有：

- `CONSTRUCTOR`：构造器的声明
- `FIELD`：域声明（包括枚举实例）
- `LOCAL_VARIABLE`：局部变量声明
- `METHOD`：方法声明
- `PACKAGE`：包声明
- `PARAMETER`：参数声明
- `TYPE`：类、接口（包括注解类型）或枚举声明。

**@Retention**

当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。

- `SOURCE`：注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视；
- `CLASS`：注解只被保留到编译进行的时候，它并不会被加载到 虚拟机中；（默认）
- `RUNTIME`：VM将在运行期间保留注解，因此可以通过反射机制读取注解的信息。

**@Document**

能够将注解中的元素包含到 Javadoc 中去。

**@Inherited**

并非说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。

**@Repeatable**

Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。

#### 1.3 定义注解

**1.3.1 注解的属性**

注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface TestAnnotation{
   
    int id() default -1;
    String msg() defaul "hit";
}
//注解中拥有 id 和 msg 两个属性
//注解中属性可以有默认值，默认值需要用 default 关键值指定。
```

赋值的方式是在注解的括号内以 `value="" `形式，多个属性之前用 `,`隔开：

```java
@TestAnnotation(id=1,msg="hello annotation")
public class Test {
}
```

需要注意的是，使用@interface自定义注解时，自动继承了`java.lang.annotation.Annotation`接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。

方法的名称就是属性的名称，返回值类型就是参数的类型（返回值类型只能是8 种基本数据类型、Class、String、enum及它们的数组）。

**1.3.2 注解的提取**

注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解

```java
public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {}
```

然后通过`getAnnotation()` 方法来获取 Annotation 对象。

```java
public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {}
//或者是 `getAnnotations()` 方法。
public Annotation[] getAnnotations() {}
```

**定义注解**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface UserCase {

    String username() default "admin";
    String password() default "admin";
}
```

**工具类**

```java
public class UserSystem {

    // 1. 测试注解，抛出异常
    public static void register (User user) throws Exception{
        // 2. 获取用户类字节码文件
        Class clazz = user.getClass();
        // 3. 反射获取成员变量
        Field filedUsername=clazz.getDeclaredField("username");
        Field filedPassword=clazz.getDeclaredField("password");
        // 4. 反射获取注解
        UserCase userCase= (UserCase) clazz.getAnnotation(UserCase.class);
        if (null!=userCase){
            filedUsername.setAccessible(true);
            filedUsername.set(user,userCase.username());
            filedPassword.setAccessible(true);
            filedPassword.set(user,userCase.password());
        }else {
            throw new Exception("注解为空");
        }

    }
}
```

**使用注解**

```java
@UserCase(username = "enosh",password ="123456")
public class User {

    private String username;
    private String password;

    public void print(){
        System.out.println("username : "+username);
        System.out.println("password : "+password);
    }
}

//测试
public class TestUser {
    public static void main(String[] args) {
        User user=new User();
        try {
            UserSystem.register(user);
            user.print();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```



### 2. 反射

反射库（reflection library）提供了一个非常强大的工具集，能够编写动态编写Java代码的程序。

#### 2.1 Class类

在程序运行期间，Java运行时系统始终为所有的对象维护一个运行时的类型标记。保存这些信息的类被称作`Class`。

**获取class对象**

- Object类中的`getClass()`方法会返回一个Class类型的实例；
- 可以通过静态方法`Class.forName(“className”)`获取类名对应的Class对象；
- `T.class`将代表匹配的类对象，如`Class c=Double[].class`。

虚拟机为每个类型管理一个Class对象，可以来比较对象的类型：

```java
if(e.getClass()==Execption.class)

```

还可以使用newInstance()快速创建一个类的实例，调用默认构造器：

```java
String s="java.util.Date";
Object o=Class.forName(s).newInstance();


```

将forName()和newInstance()配合使用，可以根据存储在字符串中的类名创建一个对象。

#### 2.2 分析类结构

Java.lang.reflect包下含有三个类Filed、Method和Constructor分别用于描述类的域、方法以及构造器。

```java
Field[] getFields();
//返回包含Field对象的数组，这些对象记录了这个类或器超类的公有域
Field[] getDeclaredFields();
//返回记录这个类全部域的数组

Method[] getMethods();
//返回所有公有方法，包括父类的公有方法
Method[] getDeclaredMethods();
//返回此类或接口的全部方法，但不含继承自父类的方法

Constructor[] getConstructors();
//返回公有构造器数组
Constructor[] getDeclaredConstructors();
//返回对象类的所有构造器


```

三个类都有一个getName()方法，返回项目的名称。Field类有一个getType()方法返回所属域类型的Class对象。

三个类还有一个getModifiers()方法，返回一个整型数值，用于描述public和static这样的修饰符使用情况。

```java
Class getDeclaredClass();
//返回一个用于描述类的Class对象
Class[] getExceptionTypes();
//返回方法抛出异常类型的Class对象数组，用于Method和Constructor

Class[] getParameterTypes();
//返回描述参数类型的class对象数组，用于Method和Constructor
Class[] getReturnType();
//返回描述返回类型的Class对象，用于Method


```

#### 2.3 运行时分析对象

```java
void setAccessible(boolean flag);
//为反射对象设置可访问标志，flag为true时表示屏蔽Java语言的访问检查，使得对象私有属性可以被查询和设置
Boolean isAccessible();
//返回反射对象的可访问标志
static void setAccessible(AccessibleObject[] array, boolean flag);

Field getField(String name);
//返回指定名称的公有域
Field getDeclaredField(String name);
//返回类中声明的给的名称的域


```

调用任意方法：在Method类中有一个invoke方法，允许调用包装在当前Method对象中的方法。

```java
Object invoke(Object obj, Object... args);
//第一个参数是隐式参数，可以被忽略，其余对象提供显示参数


```



### 3. 异常

异常是Java提供的用于程序中处理错误的一种机制。

#### 3.1 异常分类

在Java设计语言中，所有异常对象都是派生于Throwable类的一个实例：

![](https://upload-images.jianshu.io/upload_images/5982616-4ab25f2cfc5ca7b8.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp)

- Error类层次结构描述了Java运行时系统内部错误和资源耗尽错误，程序不应抛出此类异常；
- Exception类层次分为两大分支：Runtime表示由程序错误导致的异常，另一类是而程序本身没问题，但由于像I/O此类错误导致的其他异常。（`RuntimeException`这个名字容易让人产生混淆，事实上目前所有的异常都发生在运行时）

此外，Java语言规范将派生于Error和RuntimeException的异常称作未检查（unchecked）异常，此类异常编译器不检查，也不捕获。剩余其它异常称作已检查（checked）异常，故需要通过编译器检查，即必须捕获并进行处理。

#### 3.2 异常处理

##### 3.2.1 抛出异常

 找到一个合适的异常类，创建这个异常类的对象并抛出：

```java
void testExecption() throws Exception(){
    ...
    //1. 找到一个合适的异常类
    //2. 创建这个异常类的对象并抛出
    throw new Exception();
    ...
}


```

##### 3.2.2 捕获异常

要想捕获一个异常，必须是由try/catch语句块。

```java
try{
    ...
}catch(Exception e | UnkonwHostsExecption un){
    //handle this execption
}catch(MyExecption my){
    //handle myexecption
}


```

如果try中抛出的异常在catch中没有声明，则这个方法会立即终止退出。

我们还可以在catch子句中抛出一个异常，目的是改变异常的类型。

```java
try{
    access the database
}catch(SQLExecption e){
    Throwable se=new MyExaecption("database error");
    se.initCause(e);
    throw se;
}


```

使用这样的包装技术，可以使用子系统中的高级异常，而不丢失原始异常数据。

##### 3.2.3 finally子句

在try子句抛出异常并退出方法之前，会执行finally子句，即我们可以在finally子句中关闭一些资源。因为无论是否产生异常或异常是否被捕获，finally子句中的代码都会被执行。

```java
try{
   ...
   return n*n;
   
}finally{
    return n;
}


```

值得注意的是，当finally子句中包含return语句时，会产生一种意想不到的结果。如上面一段代码所示，try子句中返回值是n的平方，但在方法真正返回前，会执行finally子句中的代码，返回n使其覆盖掉原来的返回值。

但finally子句也会遇到问题，比如清理资源的方法也会抛出异常。

Jdk1.7之后为这种结构提供了一个快捷方式，使用带资源的try语句，即资源实现AutoCloseable接口，待try块退出时，自动调用close()方法和关闭资源。

##### 3.2.4 堆栈跟踪

堆栈跟踪（stack trace）是一个方法调用过程的列表，包含程序执行过程中方法调用的特定位置。可以使用Throwable类的printStackTrace()方法访问堆栈跟踪的文本描述信息。

**throwable**

```java
Throwable(String message, Throwable cause);
//使用指定的“原因”构造一个Throwable对象
Throwable initCause(Throwable cause);
//将这个对象设置成“原因”，若该对象已经被设置成“原因”，则抛出异常，返回this引用

void addSuppressed(Throwable t);
//为此异常添加一个“抑制”异常，在待资源的try语句中，t是close方法抛出的异常


```



#### 3.3 使用技巧

- 异常处理不能代替简单的测试

```java
//简单测试
if(!s.isEmpty()) s.pop();
//异常退出
try{
    s.pop();
}catch(EmptyStackExecption e){
   
}


```

异常捕获花费实践远高于前者，因此只有在异常处理情况下使用异常机制。

- 不要过分细化异常
- 利用异常层次结构：不要只抛RuntimeExecption和捕Throwable异常
- 不要压制异常
- 早抛出，晚捕获



#### 3.4 使用断言

断言机制可以允许在测试阶段向代码插入一些检查语句，当代码发布时，这些插入的检查语句会被自动地移走。因此在一个具有自我保护能力的程序中，断言很重要。

**启动和禁用断言**

在默认情况下，断言是被禁用的。可以在程序运行时使用`-enableassertions`或`-ea`选项启动断言。

```shell
java -ea MyApp


```

启动和禁用断言是类加载器的功能，无须重新编译程序。当断言被禁时，Class Loader跳过断言，因此不会降低程序运行速度。



#### 3.5 使用日志

日志管理系统管理者一个名为`Logger.global`的默认日志记录器，可以使用System.out替换它，并通过调用info()方法记录日志信息。

```java
Logger.getGlobale().info("File->XXX");


```

**日志记录器级别**

- SEVERE
- WARNING
- INFO
- CONFIG
- FINE
- FINER
- FINEST

默认情况下只记录前三个级别，也可以通过`setLevel(Level.FINE)`设置其他级别，此时，FINE和更高级的日志都被记录下来。



### 4. 泛型

泛型程序设计（Generic programming）意味着编写的代码可以被很多不同类型的对象所重用。

#### 4.1 泛型使用

**泛型类**

泛型类引入一个类型变量T，并使用尖括号（<>）括起来，放在类名之后。泛型类可以有多个类型变量，如：

```java
public class Pair<T,U>{...}


```

**泛型方法**

还可以在普通类中定义一个带类型参数的简单方法，

```java
//定义泛型方法
public static <T> T getMiddle(T.. a){...}

//调用泛型方法
String middle = Test.<String>getMiddle("John","Jack","Tom");


```

大多数情况下类型参数<String>可以省略，编译器有足够的信息推到出所调用的方法。但偶尔仍会提示错误：

```java
String middle = Test.getMiddle("John","Jack","Tom");

double middle = Test.getMiddle(3.14, 9.0, 1);


```

编译器会自动打包参数为1个Double和2个Integer类型对象，然后寻找这些类的共同超类。

**限定类型**

有时需要对类或方法的类型变量加以限定。

```java
public static <T extend Comparable& Serializable> T min(T[] a);


```

使用`&`分隔限定类型，而类型变量使用逗号分隔。

#### 4.2 虚拟机中的泛型

Java虚拟机没有泛型类型对象——所有的对象都属于普通的类对象。

无论定义一个怎样的泛型，都会自动提供一个相应的原始类型（raw type）。原始类型的名字就是删去类型参数后的泛型类型名，擦除（erased）类型变量，并替换为限定类型（无限定类型的变量使用Object）。



#### 4.3 约束和局限性

- 不能用基本类型实例化类型参数

因此没有Pair<double>，只有Pair<Double>。原因是类型擦除，类型擦除后Pair类的域只有Object，而Object不能存储double值。

- 运行时类型查询只适用于原始类型

虚拟机中的对象总有一个特定的非泛型类型，所有的类型查询只产生原始类型。

```java
new Pair<String>().getClass()==new Pair<Integer>().getClass();
//true


```

- 不能创建参数化类型（泛型）的数组

```java
Pair<String>[] table=new Pair<String>[10];  //Error


```

这是因为擦除之后table类型是Pair[]，可以转换成Object[]：

```java
Object[] array=table;


```

数组会记住其元素的类型，如果试图存储其他类型元素，会抛出ArrayStoreExecption异常。

```java
array[0] = "Hello";


```

不过对于泛型，擦除的这种机制无效，可以以下赋值:

```java
array[0] = new Pair<String>();
//能够通过数组存储检查，但由于不允许创建参数化类型的数组，会抛出一个类型错误


```

可以声明通配类型的数组，然受进行类型转换：

```java
Pair<String>[] table=(Pair<String>[]) new Pair<?>[10];


```

- Varargs警告

由于Java不支持泛型类型的数组，但当向参数个数可变的方法传递一个泛型类型实例时：

```java
public static <T> void addAll(Collection<T> coll, T... ts);


```

为调用此方法，虚拟机必须建立一个Pair<String>类型的数组，虽然违反前面规则，但此情况下规则有所放松，只会抛出一个警告。

使用`@SuppressWarnings("unchecked")`或`@SafeVarargs`注解addAll方法。

- 不能实例化类型变量
- 泛型类的静态上下文中的类型变量无效

不能在静态域或方法中引用类型变量：

```java
public class Signleton<T>{
    pravite static T singleInstance; //ERROR
    public static T getInstance(){  //ERROR
        return singleInstance;
    }
}


```

- 不能抛出或捕获泛型类的异常
- 注意擦除后的冲突



## Ⅳ Java容器

### 1. 概述

容器主要包含Collection和Map两种，Collection是存储对象的集合，而Map是存储键值对的映像表。

#### 1.1 Collection

![java collection framework image1](https://www.w3resource.com/w3r_images/java-collections.png)

- **List**：有序可重复

| 实现类       | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| `ArrayList`  | 基于动态数组实现，支持随机访问                               |
| `Vector`     | 与ArrayList 类似，但它是线程安全的，但已过时，若需要实现同步可以调用Collections工具类的synchronizedList方法 |
| `LinkedList` | 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列 |

1. ArrayList没有定义增长算法，当需要插入大量元素是，可调用ensureCapacity方法提高添加效率；
2. Vector类似与ArrayList，但是是同步的，多线程安全（另外一点区别是ArrayList扩容时默认增长一半，Vector增长一倍）



- **Set**：无序不重复，可最多含一个null元素（无序因而不能通过索引操作对象）

| 实现类          | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| `HashSet`       | 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的 |
| `LinkedHashSet` | 具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序 |
| `TreeSet`       | 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN) |

#### 1.2 Map

- **Map**：映射不能包含重复键

![](https://www.w3resource.com/w3r_images/java-collections1.png)

| 实现类          | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| `HashTable`     | 类似HashMap，但是线程安全的。它是遗留类，不宜使用。可用ConcurrentHashMap 来支持线程安全，并且效率更高，因为 ConcurrentHashMap 引入了分段锁 |
| `HashMap`       | 基于哈希表实现                                               |
| `LinkedHashMap` | 使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序 |
| `TreeMap`       | 基于红黑树实现                                               |



### 2. 源码分析

源码基于 JDK 1.8，使用Idea快捷键`Ctrl+B`调出。

#### 2.1 ArrayList

**概览**

```java
public class ArrayList<E> extends AbstractList<E> implements List<E>,
         RandomAccess, Cloneable, java.io.Serializable{
     //初始容量
     private static final int DEFAULT_CAPACITY = 10;
     //基于数组实现，支持快速的随机访问
     transient Object[] elementData; // non-private to simplify nested class access
     //transient 关键字被用来表示变量将不被序列化处理
}
```

**扩容**

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
    //扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作的代价较高
}
```

添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 `oldCapacity + (oldCapacity >> 1)`，即旧容量的 1.5 倍。

**删除**

```java
public E remove(int index) {
    rangeCheck(index);
    modCount++;
    E oldValue = elementData(index);
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work
    return oldValue;
}
```

需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)。

**序列化**

ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。

```java
private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size > 0) {
        // be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i<size; i++) {
            a[i] = s.readObject();
        }
    }
}
```

**Fail-Fast（快速失败）**

ArrayList使用`modCount`来记录结构发生变化的次数。在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，若产生变化需要抛出 ConcurrentModificationException（如某个线程对该 collection 在结构上对其做了修改）。

```java
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i<size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
```

**Fail-Safe（安全失败）**

对于采用fail-safe机制来说，就不会抛出异常。因为fail-safe机制会在复制原集合的一份数据出来，然后在复制的那份数据遍历。所以fail-safe机制存在两个缺点：

1. 复制时需要额外的空间和时间上的开销。
2. 不能保证遍历的是最新内容。

java.util包下的集合类都是快速失败机制的，不能在多线程下发生并发修改（迭代过程中被修改）；

java.util.concurrent包下的容器都是安全失败的，可以在多线程下并发使用,并发修改。

#### 2.2 Vector

**同步**

实现与 ArrayList 类似，但是在所有修改结构的方法使用 synchronized 内置锁进行同步。

```java
//初始大小为10
public Vector() {
     this(10);
}
```

**扩容**

Vector 的构造函数可以传入 capacityIncrement （增长量）参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。

```java
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

**代替方案**

- 在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList。但不推荐，因为增删造成的同步锁可能会阻塞遍历操作。
- 使用CopyOnWriteArrayList来替换ArrayList。推荐使用该方案

#### 2.3 CopyOnWriteArrayList

CopyOnWriteArrayList会在一个复制的新数组上进行写操作，同时写操作使用ReentrantLock加锁。而读操作还是在原始数组中进行。写操作结束之后把原始数，将新数组的索引赋值给原始数组。

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

final void setArray(Object[] a) {
    array = a;
}
```

CopyOnWriteArrayList 在写操作的同时允许读操作，读写分离，互不影响，大大提高了读操作的性能。并实现**fail-safe**机制。

#### 2.4 LinkedList

```java
//基于双向链表实现，使用 Node 存储链表节点信息。
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
}

transient Node<E> first;    //Pointer to first node.
transient Node<E> last;    //Pointer to last node.
```

- ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；
- ArrayList 支持随机访问，LinkedList 不支持；
- LinkedList 快速的在任意位置添加删除元素。

#### 2.5 HashMap

**实现**：数组+链表

```java
transient Node<K,V>[] table;
//Node存储着键值对。从next字段可以看出Node是一个链表。
//即数组中的每个位置被当成一个桶，一个桶存放一个链表。
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;
}

//默认初始大小为16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```

**Put**

HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    //(n - 1) & hash 计算桶的位置
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    //进入这里说明桶的位置已经放入过数据了
    else {
        Node<K,V> e; K k;
        //判断put的数据和之前的数据是否重复
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            //覆盖原有值
            e = p;
        //判断是否是红黑树，如果是红黑树就直接插入树中
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            //如果不是红黑树，就遍历每个节点
            for (int binCount = 0; ; ++binCount) {
                //判断链表长度是否大于8，如果大于就转换为红黑树
               if ((e = p.next) == null) {
                   p.next = newNode(hash, key, value, null);
                   if (binCount >= TREEIFY_THRESHOLD - 1) //TREEIFY_THRESHOLD = 8
                       treeifyBin(tab, hash);
                   break;
               }
               //判断索引每个元素的key是否可要插入的key相同，如果相同就直接覆盖
               if (e.hash == hash &&
                   ((k = e.key) == key || (key != null && key.equals(k))))
                   break;
               p = e;
            }
       }
        //如果e不是null，说明跳出了循环，链表中有相同的key，因此只需要将value覆盖，返回oldValue即可
       if (e != null) { // existing mapping for key
           V oldValue = e.value;
           if (!onlyIfAbsent || oldValue == null)
               e.value = value;
           afterNodeAccess(e);
           return oldValue;
       }
   }
   //说明没有key相同，因此要插入一个key-value，并记录内部结构变化次数
   ++modCount;
   if (++size > threshold)
      resize();
   afterNodeInsertion(evict);
   return null;
}

//HashMap使用第0个桶存放键为null的键值对。
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

计算的hash值右移16位，即自己的高半区和低半位区做异或，混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。

![](https://pic4.zhimg.com/80/4acf898694b8fb53498542dc0c5f765a_hd.jpg)

**Get**

```java
final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    //如果表不是空的，并且要查找索引处有值，就判断位于第一个的key是否是要查找的key
    if ((tab = table) != null && (n = tab.length) > 0 &&
       (first = tab[(n - 1) & hash]) != null) {
       if (first.hash == hash && // always check first node
           ((k = first.key) == key || (key != null && key.equals(k))))
           //如果是，就直接返回
           return first;
       //如果不是就判断链表是否是红黑二叉树，如果是，就从树中取值
       if ((e = first.next) != null) {
           if (first instanceof TreeNode)
               return ((TreeNode<K,V>)first).getTreeNode(hash, key);
           //如果不是树，就遍历链表
           do {
               if (e.hash == hash &&
                   ((k = e.key) == key || (key != null && key.equals(k))))
                   return e;
           } while ((e = e.next) != null);
       }
    }
    return null;
}
```

**扩容**

```java
/**
* Initializes or doubles table size.  If null, allocates in
* accord with initial capacity target held in field threshold.
* Otherwise, because we are using power-of-two expansion, the
* elements from each bin must either stay at same index, or move
* with a power of two offset in the new table.
*
* @return the table
*/
final Node<K,V>[] resize() {
}
```

- HashTable 使用 synchronized 来进行同步。
- HashMap 可以插入键为 null 的 Entry。
- HashMap 的迭代器是 fail-fast 迭代器。
- HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。

#### 2.6 ConcurrentHashMap

ConcurrentHashMap和HashMap实现上类似，最主要的差别是ConcurrentHashMap采用了分段锁Segment，每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。

```java
//Segment 继承自 ReentrantLock
static class Segment<K,V> extends ReentrantLock implements Serializable {
    private static final long serialVersionUID = 2249069246763182397L;
    final float loadFactor;
    Segment(float lf) { this.loadFactor = lf; }
}

//默认的并发级别为 16，也就是说默认创建 16 个 Segment
private static final int DEFAULT_CONCURRENCY_LEVEL = 16;
```

#### 2.7 LinkedHashMap

继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。

```java
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>
```

内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。

```java
//The head (eldest) of the doubly linked list.
transient LinkedHashMap.Entry<K,V> head;

//The tail (youngest) of the doubly linked list.
transient LinkedHashMap.Entry<K,V> tail;

//accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序
final boolean accessOrder;
```

LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。

```java
void afterNodeAccess(Node<K,V> p) { }
void afterNodeInsertion(boolean evict) { }
```

**afterNodeAccess**

当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。

**afterNodeInsertion**

在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。evict 只有在构建 Map 的时候才为 false，在这里为 true。

```java
void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry<K,V> first;
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}

protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
    return false;
}
```

#### 2.8 WeakHashMap

WeakHashMap的Entry继承自WeakReference，被WeakReference关联的对象在下一次垃圾回收时会被回收。

WeakHashMap主要用来实现缓存，通过使用WeakHashMap来引用缓存对象，由 JVM 对这部分缓存进行回收。

```java
private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V>
```

**ConcurrentCache **

Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。

```java
public final class ConcurrentCache<K, V> {

    private final int size;

    private final Map<K, V> eden;

    private final Map<K, V> longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap<>(size);
        this.longterm = new WeakHashMap<>(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() >= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
```

- 经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；
- 不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。
- 当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。
- 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。



## Ⅴ 并发编程

### 1. 前言

#### 1.1 并发编程的优势

- 发挥多处理器的强大能力
- 建模的简单性
- 异步事件的简化处理
- 用户界面响应更加灵敏

#### 1.2 线程带来的风险

- **安全性问题**：在没有充分同步的情况下，多个线程中的操作执行顺序不可预测（UnsafeSequence）
- **活跃性问题**：当某个操作无法继续执行，便出现活跃性问题。如饥饿、死锁
- **性能问题**：活跃性意味着正确的事情终会发生，但效果并不够理想



### 2. 线程安全

> **安全性**：程序的行为于其规范完全一致
>
> 一个对象是否是线程安全的，却决于它能否被多个线程访问
>
> 无状态对象一定是线程安全的。非正式讲，对象的状态指存储在状态变量（实例或静态域）中的数据

#### 2.1 原子性

- **竞态条件**（Race Condition）：由于不恰当的执行时序而出现不正确的结果，即当某个计算的正确性取决于多个线程的交替时序时，便发生了竞态条件。
- 先检查后执行：Check-then-Act
- 和大多数并发错误一样，竞态条件并不总会发生错误，还需要不恰当的执行时序
- 若以原子方式执行操作，则可以避免竞态条件问题

#### 2.2 加锁机制

##### 2.2.1 内置锁

> 同步代码块（Synchronized Block)

```java
//object作为锁的对象引用，sychronized关键字可以修饰方法和代码块
sychronized (object){
    //保护的代码块
}
```

- 每一个Java对象都可以作为一个实现同步的锁，称作内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）；
- 内置锁是互斥锁，即最多只有一个线程持有这种锁；
- 获取内置锁的唯一途径就是进入这个锁保护的代码块或方法中。

##### 2.2.2 重入

> 一个线程可以成功请求它已经持有的锁

- **重入**意味着获取锁的操作的粒度是” 线程 “，而非” 调用 “

- 重入的实现：每个锁都关联一个计数器和一个所有者线程

- 重入的作用：提升了加锁行为的封装性，简化并发代码

  ```java
  class Father{
 
      public synchronized void doSomething(){
          System.out.println("father's this is: "+this);
      }
  }
 
  class Son extends Father{
      @Override
      public synchronized void doSomething() {
          super.doSomething();
          System.out.println("son's this is: "+this);
      }
  }
  //----------------调用子类doSomething方法结果-------------
  father's this is: com.enosh.javastudy.concurrency.sync.Son@29453f44
  son's this is: com.enosh.javastudy.concurrency.sync.Son@29453f44
  ```

  1. 父类中的<this>的值和子类一致，是子类的引用
  2. 两次调用获取的锁都是子类的对象锁，即内置锁是可重入的

#### 2.3 用锁保护状态

> 锁可以保护代码路径以串行形式访问，可以通过锁来构造一些协议实现对共享状态的独占访问

- 每个共享的和可变的变量都应该只由一个锁来保护
- 对于每个包含多个变量的不变性条件，涉及的所有变量都需要由同一个锁来保护

#### 2.4 活跃性与性能

- 判断同步代码块的合理大小
- 耗时操作（IO）定不能持有锁



### 3. 对象的共享

#### 3.1 可见性

- **内存可见性**（Memory Visiblity）:我们不仅希望可以阻止另一个线程同时访问对象状态，而且希望当一个线程修改对象的状态后，其他线程能够发现状态的变化
- 在没有同步的情况下，编译器、处理器和运行时等都可能对操作的执行顺序进行一些意想不到的调整
- 加锁的含义不仅局限于互斥行为，还包括可见性

#### 3.2 Volatile

- 一种稍弱的同步机制，当将变量声明成Volatile类型后，虚拟机和运行时都会注意的这个变量时共享的，因此该变量上的操作不会与其他内存操作一起重排
- 加锁机制既可以确保可见性，又可以保证原子性，而volatile变量只能确保可见性
- 注意最该使用volatile的条件：
  1. 只有单个线程更新变量的值
  2. 该变量不会与其他变量一起纳入不变性条件
  3. 在访问变量时不需要加锁

#### 3.3 发布和逸出

> 1. **发布**（Publish）一个对象是指，使对象能够在当前作用域之外的代码中使用，如将对象引用传递到其它类的方法中
> 2. **逸出**（Escape）是指一个不应该发布的对象被发布

- 发布对象最简单的方法时将对象的引用保存到公有的静态变量中
- 发布一个对象时，该对象的非私有域中所有引用对象同样被间接发布
- 发布内部状态会破坏封装性和不变性条件，所以我们发布对象的同时注意控制对象的逸出
- 不要在构造函数中**启动**一个线程。因为this引用会被构造函数中创建的线程共享，而当前构造函数还没有完成，却可能运行了线程，导致this还没有构造完成却被运行，产生诡异问题

#### 3.4 线程封闭

> 当访问共享的可变数据时，通常需要同步。一种避免同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步，这种技术称为**线程封闭**<Thread  Confinement>

- **Ad-hoc 线程封闭**：维护线程封闭的职责完全由程序实现来承担，是非常脆弱的，因此在程序中尽量少使用，一般使用更强的线程封闭技术，比如栈封闭或者ThreadLocal类
- **栈封闭**：是线程封闭中的一种特例，在栈封闭中只能通过局部变量才能访问对象
- **ThreadLocal**：这个类可以将线程中的某个值与保存值的对象关联起来，通常用于防止可变的单例实例对象和全局变量进行共享

#### 3.5 不变性

> 满足同步需求的另一种方法是使用不可变对象（Immutable Object）

- 不可变对象一定是线程安全的
- 不可变性不等于将对象的所有域都声明为<final>类型，因为<final>类型的域中可以包含可变对象的引用

**Final域**：

- final域可以确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享是无须同步

#### 3.6 安全发布

- **线程安全容器**：Hashtable，sychronizedMap，sychronizedList，sychronizedSet，ConcurrentMap，Vector，CopyOnWriteArrayList，CopyOnWriteArraySet，BlockingQuene，ConcurrentLinkedQuene
- **事实不可变对象**：对象在技术上可变，但其状态在发布后不会再变化
- 安全共享对象：
  1. 不可变对象可以由任意机制发布
  2. 事实不可变对象需用安全方式发布，如使用安全的容器
  3. 可变对象必须通过安全方式发布，且必须是线程安全或使用某个锁保护



### 4. 对象组合

> 将现有的线程安全组件组合成更大规模的组件或程序

- **设计线程安全的类**：收集同步需求，依赖状态的操作，状态的所有权
- **实例封闭**：将数据封装在对象的内部
- **线程安全性的委托**：
- 在现有的线程安全类中添加功能
- 将同步策略文档化



### 5. 基础构建模块



### 6. 任务执行

#### 6.1 Executor框架

> 任务是一组逻辑工作单位，而线程则是使任务异步执行的机制

- 在Java中执行任务的主要抽象不是**Thread**，而是**Executor**，基于生产者——消费者模式
- 同时，当希望获得一种更加灵巧的执行策略时，使用Executor代替Thread

```java
public interface Executor{
    void excute (Runnable command);
}
```

**线程池**

| 类型                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| newFixedThreadPool      | 将创建一个固定大小的线程池，每当提交一个任务就创建一个线程   |
| newCachedThreadPool     | 创建一个可缓存的线程池，规模不受限制，当规模超过需求则回收空闲线程 |
| newSingleThreadExecutor | 单线程的Executor，若异常结束则创建新线程来代替               |
| newScheduledThreadPool  | 固定长度线程池，但可以延迟或定时执行任务                     |

**Executor生命周期**

- JVM只有在所以非守护线程结束后才会退出，所以无法正确关闭Executor会导致JVM无法结束
- **ExecutorService**拓展了Executor接口，添加了一些用于管理生命周期的方法

```java
public interface ExcutorService extends Executor{
    void shutdown();    //执行平缓的关闭过程，等待所有任务的执行
    List<Runnable> shutdownNow();    //执行粗暴的关闭过程，返回尚未启动的任务清单
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    //执行awaitTermination后会立即调用shutdown，同时产生关闭ExcutorService的效果
}
```

**Timer**

- 问题：
  1. Timer执行所有定时任务时只会创建一个线程，一个任务执行过长，将会破坏其他TimerTask的定时精确
  2. **线程泄露问题**：Timer线程不会捕获异常，当TimerTask抛出未检查的异常时，错误认为整个Timer都被取消，将终止定时任务
- 解决：
  1. 使用**ScheduledThreadPoolExecutor**代替
  2. 使用**DelayQuene**构建自己的调度服务

#### 6.2 Callable和Future

> Executor框架使用Runnable作为基本任务的表示形式，run可以写入日志或放入共享数据结构，但具有很大的局限性，并不能返回一个值或者抛出一个受检查的异常

- **Callable**是一个更好的任务抽象，为主入口点（Call）返回一个值或异常
- **Future**表示一个任务的生命周期，并提供相应的方法判断任务是否完成、获取结果、取消任务等

```java
public interface Callable<V> {
    V call () throws Exception;
}

public interface Future<V> {
    boolean cancel (boolean mayInterrupIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException, CancellationException;
    V get(long tiomout, TimeUnit unit) throws InterruptedException, ExecutionException, CancellationException;
   
    //get方法的行为取决于任务状态，若任务已经完成，立即返回或抛出异常，若任务尚未完成，get将会被阻塞直到任务完成
}
```

- ExecutorService中的所有submit方法都将返回一个Future，还可以为Runnable或Callable实例化一个**FutureTask**

#### 6.3 CompletionService

> CompletionService融合了Executor和BlockingQuene，将Callable任务提交给它，然后使用take和poll等操作获取已完成的结果，这些结果是封装好的Future

- ExecutorCompletionService实现CompletionService，并将计算部分委托给一个Executor

```java
private class QueneingFuture<V> extends FutureTask<V>{
    QueneingFuture(Callable<V> c){super(c);}
    QueneingFuture(Runnable<V> t,V r){super(t,r);}
   
    protected void done() {
        completionQuene.add(this);
    }
    //ExecutorCompletionService实现原理非常简单，在构造函数中创建一个BlockingQuene保存计算结果，提交任务时，首先将任务包装成一个FutureTask的子类QueneingFuture,再改写done方法
}
```

### 7. 取消和关闭

> Java没有提供任何机制来快速安全的终止线程，但它提供了**中断**<Interruption>这种协作机制，让一个线程终止另一个线程

#### 7.1 任务取消

- 取消操作的原因：用户请求、时间限制、应用事件、错误、关闭
- 一个可取消的任务必须拥有取消策略（Cancellation Policy）

```java
  //使用volatile类型的域保存取消状态
  public class Test implements Runable {
      private volatile boolean cancelled;

      public void run(){
          while (!cancelled){
              //To DO
              //调用阻塞方法后可能检查不到取消标志位，永远不会停止
          }
      }

      public void cancel(){cancelled = true;}
  }
```

##### 7.1.1 中断

> 线程中断是一种协作机制，线程可以通过此机制来通知另一个线程，告诉它在合适或者可能的情况下终止

```java
//Thread中的中断方法
public class Thread {
    //中断目标线程
    public void interrupt(){}
    //返回中断线程的状态
    public bollean isInterrupted(){}
    //清除当前线程的中断状态，并返回之前的值，这也是清除中断状态的唯一方法
    public static boolean interrupted(){}
}
```

- 调用interrupt并不意味着停止目标线程，而只是传递请求中断的信号，然后由线程在下一个合适的取消点中断自己
- wait，sleep，join等方法也将严格执行这种请求

#### 7.2 停止基于线程的服务

- 对于持有线程的服务，只要服务的存在时间大于创建线程方法的时间，就应该提供生命周期方法
- 关闭ExecutorService：shutdown（执行所有任务） 和shutdownNow（返回尚未启动的任务清单）
- “**毒丸**”对象：指放入队列的对象，当得到该对象时立即停止

#### 7.3 处理非正常线程终止

> 导致线程提前死亡的最主要的原因就是**RuntimeException**。
>
> 这种异常表示出现某种编程错误或其它不可修复的错误，通常不会被捕获，也不会在调用栈中逐级传递，而是默认输出到控制台，并终止线程

- **UncaughtExceptionHandler**：检查出某个线程由于未捕获的异常而终结情况

```java
public interface UncaughtExceptionHandler {
    void uncaughtException(Thread t, Throwable e);
}

public class XXXLogger implements Thread.UncaughtExceptionHandler {
    public void uncaughtException(Thread t, Throwable e){
        //to do something
    }
}
```

#### 7.4 JVM关闭

> - 正常关闭：最后一个非天使线程结束、调用System.exit()、平台特定方法
> - 强行关闭：调用Runtime.halt()、OS关闭JVM进程

**关闭钩子（Shutdown Hook）**

- 关闭钩子是指通过Runtime.addShutdownHook注册的但尚未开始的线程

在正常的关闭中，JVM首先调用所有已经注册的关闭钩子，但并不能保证关闭钩子的调用顺序。

关闭钩子可以用于实现服务或应用程序的清理，如删除临时文件、清理无法由OS自动清除的文件

```java
public void start() {
    Runtime.getRuntime().addShutdownHook(new Thread(){
        public void run() {
            // to do
        }
    });
}
```

**守护线程**

> **守护线程**：在JVM启动时所创建的所有线程中，除主线程以外其余都是守护线程（如垃圾回收器以及其他执行辅助工作的线程）
>
> **普通线程**：默认情况下，主线程创建的所有线程都是普通线程

- 二者区别仅存在于线程退出时发生的变化，当一个线程退出时，JVM会检查其他线程的状态，如果仅剩守护线程，JVM会进行正常退出；

- 当JVM停止时，所有存活的守护线程会被直接抛弃——既不执行finally代码块，也不执行回卷栈，JVM直接退出。

**终结器**

> 当不需要内存资源时，可以通过GC回收，但一些如文件句柄或套接字句柄的资源必须显式的交还给操作系统

- 垃圾回收期对定义了<finalize>方法的对象进行特殊处理：回收器释放它们后调用其finalize方法，从而保证一些持久化的资源被释放
- 避免使用终结器，因为终结器无法保证它们何时运行或是否运行。一般情况我们使用finally代码块和显式的close方法

### 8. 显示锁

> 并非取代内置锁，而是在内置锁机制不适用时作为可选择的高级功能

#### 8.1 ReentrantLock

```java
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
//ReentrantLock实现Lock接口，提供域synchronized相同的互斥性和可见性
Lock lock = new ReentrantLock();
lock.lock();
try{
    //to do
} finally{
    lock.unlock();
}
```

- 轮询锁和定时锁
- 可中断的锁
- 非块结构的加锁：连锁式加锁（Hand-Over-Hand Locking）或锁耦合（Lock Coupling）

**公平性**

ReentrantLock的构造函数可以创建一个非公平的锁（默认）或一个公平的锁，而内置锁同样不会提供确定的公平性保证

**ReentrantLock和Synchronized**

在一些内置锁无法满足需求的情况下，如需要某些高级功能：可定时、可轮询、可中断、公平队列以及非块结构的锁时使用ReentrantLock，否则应该**优先使用Synchronized**

#### 8.2 读-写锁

- **ReentrantReadWriteLock**

```java
public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}
```

# 二、Web

## Ⅰ Servlet

### 1. 概述

> Servlet技术是一种基于Java语言，用于创建Web应用程序(处在服务器端并生成动态网页)。
>
> 狭义的Servlet是指Java语言的接口，广义上讲是指实现这个Servlet接口的类。

继承HttpServlet，并从写service()方法：

```java
public class MyServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.getWriter().write("<h1>Hello Servlet !!!</h1>");
    }
}
```

配置`WEB-INF`目录下的`web.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                             http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!--配置servlet-->
    <servlet>
        <servlet-name>myservlet</servlet-name>
        <servlet-class>com.enosh.study.servlet.MyServlet</servlet-class>
    </servlet>
    <!--配置访问路径-->
    <servlet-mapping>
        <servlet-name>myservlet</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

#### 1.1 访问流程

URL组成：http://服务器地址:端口号/虚拟项目名/servlet别名

浏览器发送请求到服务器，服务器根据请求URL的信息在webapps目录下找到对于项目的文件夹，然后在webxml中检索对应servlet的class文件并调用执行。

同时，使用servlet的真实名称`/com.enosh.study.servlet.MyServlet `亦可访问该servlet。



#### 1.2 生命周期

servlet的生命周期通常是从第一次请求加载进内存至服务器关闭而销毁。

```java
//初始化方法，在第一次调用servlet时被调用
public void init() throws ServletException;

//处理请求的方法
protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException;

//销毁方法是在servlet对象被销毁时，即服务器关闭时调用
public void destroy();
```

若在`web.xml`文件中配置了`load-on-start`属性：

- 其值为非负时，则在服务器启动时便加载servlet至内存，并调用ini()方法。
- 且数值越大，优先级越高，启动时优先加载，当数值相同，则由容器自己选择加载顺序。
- 但其值为负，则不启动不加载。

项目任意类文件发生变化后，才会重新编译并输出到目标文件。



### 2. 常用方法

#### 2.1 doGet & doPost

- **service**：可以处理get/post方法请求，如果servlet中由service方法，会优先调用service方法对请求进行处理；
- **doGet**：处理get方法请求；
- **doPost**：处理post方法请求。

如果在覆写service的方法红调用了父类的service，即super.service()，则service执行之后会在此根据请求相应doGet或doPost方法。所以我们要避免在service中调用父类方法，避免405错误。



#### 2.2 Request

request对象由Tomcat容器创建，封装了当前请求的所有信息，并作为实参传递给处理请求的servlet对象中的service方法。

- 获取请求行数据

```java
//获取请求方法
req.getMethod();
//获取请求URL
req.getRequestURL();
//获取请求URI
req.getRequestURI();
//获取协议
req.getScheme();
```

- 获取请求头数据

请求头是HTTP的报文头。报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息，以及与缓存相关的规则信息，均包含在header中。

```java
//获取指定请求头信息
req.getHeader("User-Agent");
//获取所有请求头信息，返回所有请求体键名的枚举
Enumeration e = req.getHeaderNames();
```

- 获取请求体信息

是报文体，它将一个页面表单中的组件值通过param1=value1&param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。

```java
//获取指定请求体信息
String str=req.getParameter("username");
//objects=1&objects=2&objects=3
String[] objects = req.getParameterValues("objects");
//获取所有请求体信息
Enumeration enumeration = req.getParameterNames();
```

如果获取的请求数据不存在，服务器不会报错，而是返回`null`。



#### 2.3 Response

- 设置响应头

```java
//设置响应头，同键覆盖
resp.setHeader("name","admin");
//添加响应头，同键不会覆盖
resp.addHeader("key","value");
```

- 设置响应编码设

```java
resp.setHeader("content-type","text/html;charset=utf-8");
resp.setContentType("text/html;charset=utf-8");
```

- 设置响应状态码

```java
resp.sendError(405,"This method is not supported");
```

- 设置响应实体

```java
resp.getWriter().write("This method is not supported");
```



#### 2.4 请求乱码

方法一：使用String进行重新编码

```java
String str=new String(str.getBytes("ios8859-1"),"utf-8");
```

方法二：

在获取请求数据之前设置：`req.setCharacterEncoding("utf-8")`；

配置Tomcat的server.xml文件：添加`useBodyEncodingForURI`表签，并设置为`true`。

#### 2.5 请求转发

实现多个servlet的联动操作来处理请求，避免代码冗余，可以明确各个servlet的职责。

```java
//跳转至新的servlet
req.getRequestDispatcher("/").forward(req,resp);
//请求转发后建议return结束
return;
```

特点：一次请求（**服务器内部跳转**），浏览器地址栏信息不会发生变化。

#### 2.6 重定向

用于解决表单重复提交的问题，以及当前请求servlet无法处理的问题。

```java
resp.sendRedirect("/");
```

特点：两次请求（**浏览器进行的二次请求**），两个request对象。

- 请求转发可以共享请求参数 ，重定向之后，就获取不了共享参数；
- 请求转发不能跨域（不能访问其他服务器链接），重定向可以 ；
- 请求转发能转到WEB-INF目录下的文件，而重定向不能 。

### 3. 数据存储

#### 3.1 Cookie

浏览器端的数据存储技术，解决不同请求间数据共享的问题。

```java
//创建Cookie对象
Cookie cookie=new Cookie("study","servletStudy");
//设置Cookie的有效期
cookie.setMaxAge(3*24*3600);
//设置路径
cookie.setPath("/");
//响应Cookie信息给浏览器
resp.addCookie(cookie);
```

一个Cookie对象存储一条数据，多条数据可以创建多个Cookie对象进行存储。

- 临时存储：存储在浏览器端的运行内存中，浏览器关闭即失效；
- 定时存储：设置Cookie的有效期，存储在客户端的硬盘中，在有效期内符合路径要求的请求都会附带该信息。

#### 3.2 Session

解决一个用户不同请求处理的数据共享问题。

使用Session技术，用户第一次访问时服务器会创建一个session对象给此用户，并将该对象的JESSIONID使用Cookie技术存储在浏览器中，保证用户的其它请求能够获取到同一个session对象，也保证了不同请求能够获取到共享数据。

```java
//创建或获取对象
HttpSession hs=req.getSession();
```

如果请求中拥有session的标识符也就是JSEESIONID，则返回对于的session对象；若没有标识符或session失效，就会重新创建一个session对象。

```java
//设置session存储时间（默认30分钟）
hs.setMaxInactiveInterval(int seconds);
//设置session强制失效
hs.invalidate();
```

还可以在tomcat或项目web.xml配置session：

```xml
<session-config>
    <session-timeout>30</session-timeout>
</session-config>
```

在指定时间内session对象没有使用则被销毁，若使用，则会重新计算。

```java
//存储数据
hs.setAttribute("key","value");
//获取数据
hs.getAtrribute("key");
```

注意：JSEESIONID存储在Cookie的临时存储空间中，即关闭浏览器失效。



**ServletContext**

解决不同用户间数据共享的问题，由服务器创建，在整个项目内的所有用户间共享。

```java
//获取ServletContext
ServletContext sc= getServletContext();
ServletContext sc1= getServletConfig().getServletContext();
ServletContext sc2= req.getSession().getServletContext();
```

- 存储公共对象

```java
//存储数据
sc.setAttribute("key","value");
//获取数据
sc.getAtrribute("key");
```

- 获取web.xml的公共配置

作用：将静态数据与代码进行解耦。

```java
String str = sc.getInitParameter("key");
```

```xml
<!-- 一组标签之只能存放一组键值对 -->
<context-param>
    <param-name>key</param-name>
    <param-value>value</param-value>
</context-param>
```

- 获取项目根目录路径资源

```java
//Str path = "D:\\Apache-Tomcat-8.5.43\\webapps\\example\\docs\\1.txt";
//获取项目根目录下的资源绝对路径
String path =sc.getRealPath("/docs/1.txt");

//获取根目录资源流对象
InputStream is=sc.getResourceAsStream("/docs/1.txt");
```



**ServletConfig**

ServletConfig对象是servlet的专属配置对象，每个servlet都有一个单独的servletConfig对象，用来获取web.xml中的配置信息。

```java
//获取servletConfig对象
ServletConfig sc=getServletConfig();
//获取web.xml中的配置
String value= sc.getInitParameter("key");
```

xml中的配置：

```xml
<servlet>
    <servlet-name>myservlet</servlet-name>
    <servlet-class>com.enosh.study.servlet.MyServlet</servlet-class>
    <init-param>
        <param-name>key</param-name>
        <param-value>value</param-value>
    </init-param>
</servlet>
```

### 4. 文件配置

#### 4.1 web.xml

每个Web项目中和Tomcat容器conf目录下都会有一个`web.xml`文件。用于存储向相关的配置信息，包含Servlet，以及解耦一些数据对程序的依赖。

其中，Web项目的web.xml文件为局部配置，针对该项目，而Tomcat目录下的文件时全局配置，配置公有信息。

核心组件：全局上下文配置，Servlet配置，过滤器配置，监听器配置。

加载顺序：ServletContext --> context-param --> listener --> filter -->servlet，即这些元素标签的位置可以任意。

#### 4.2 server.xml

其中每一个元素都对应了Tomcat中的每一个组件，因此通过对xml文件中元素的配置可以实现对Tomcat中各个组件的控制。

```xml
<Server>
    <Service>
        <Connector>
        </Connector>
        <Engine>
            <Host>
                <Context />
            </Host>
        </Engine>
    </Service>
</Server>
```

Server在最顶层，代表整个Tomcat容器，一个Server元素中可以有一个或多个Service元素。

Service将Connector和Engine组装起来，对外提供服务。一个Service可以包含多个Connector，但是只能包含一个Engine。

Connector接收请求，Engine处理请求。

Engine、Host和Context都是容器。每个Host组件代表Engine中的一个虚拟主机，每个Context组件代表在特定Host上运行的一个Web应用。

**热部署**：

```xml
<Context path"/" reloadable="false" docBase="D:/webapps" />
```

# 三、Spring

## Ⅰ Spring框架

Spring是一个开放源代码的设计层面框架，它解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。

Spring是一个容器框架，它可以接管Web层，业务层，Dao层，持久层的各个组件，并且可以配置各种Bean， 并可以维护Bean之间的关系，当我们需要使用某个Bean的时候，我们可以直接调用getBean(id)即可。

- **ioc（inverse of control）控制反转：**所谓反转就是把创建对象和维护对象的关系的权利从程序转移到Spring的容器；
- **di（dependency injection）依赖注入：**实际上di和ioc是同一个概念，spring的设计者认为di更准确的表示spring的核心。



### 1. Spring体系结构

> Spring是模块化的，提供了约20个功能模块，可以根据应用程序的要求来使用。

#### 1.1 核心容器

- **spring-core**模块提供了框架的基本组成部分，包括 IoC 和依赖注入功能。
- **spring-beans** 模块提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。
- **context**模块建立在由**core**和 **beans** 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。Context模块继承自Bean模块，并且添加了国际化（比如使用资源束）、事件传播、资源加载和透明地创建上下文（比如通过Servelet容器）等功能。Context模块也支持Java EE的功能，比如EJB、JMX和远程调用等。**ApplicationContext**接口是Context模块的焦点。**spring-context-support**提供了对第三方库集成到Spring上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。
- **spring-expression**模块提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。

#### 1.2 数据访问/集成

- **JDBC** 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。
- **ORM** 模块提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。
- **OXM** 模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。
- **JMS** 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。
- **事务**模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细）

#### 1.3Web

- **Web** 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。
- **Web-MVC** 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。
- **Web-Socket** 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。
- **Web-Portlet** 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。

#### 1.4 其他

- **AOP** 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。
- **Aspects** 模块提供了与 **AspectJ** 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。
- **Instrumentation** 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。
- **Messaging** 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。
- **测试**模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。



### 2. Spring IoC 容器

> Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。

Spring 提供了以下两种不同类型的容器：

| 容器                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| BeanFactory 容器        | 它是最简单的容器，给 DI 提供了基本的支持，它用 org.springframework.beans.factory.BeanFactory 接口来定义。（但已废弃） |
| ApplicationContext 容器 | 该容器添加了更多的企业特定的功能，例如从一个属性文件中解析文本信息的能力，发布应用程序事件给感兴趣的事件监听器的能力。该容器是由 org.springframework.context.ApplicationContext 接口定义。 |

#### 2.1 ApplicationContext

> ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会更加优秀。当然，BeanFactory 仍可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。

最常被使用的 ApplicationContext 接口实现：

- **FileSystemXmlApplicationContext**：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径。
- **ClassPathXmlApplicationContext**：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。
- **WebXmlApplicationContext**：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。

#### 2.2 Bean定义

| 属性                | 属性名          | 描述                                                         |
| ------------------- | --------------- | ------------------------------------------------------------ |
| calss               | calss           | 这个属性是强制性的，并且指定用来创建 bean 的 bean 类         |
| name                | name            | 这个属性指定唯一的 bean 标识符                               |
| scope               | scope           | 这个属性指定由特定的 bean 定义创建的对象的作用域             |
| constructor-arg     | constructor-arg | 它是用来注入依赖关系的                                       |
| properties          | property        | 它是用来注入依赖关系的                                       |
| autowiring          | autowire        | 它是用来注入依赖关系的                                       |
| lazy-initialization | lazy-init       | 延迟初始化的 bean 告诉 IoC 容器在它第一次被请求时，而不是在启动时去创建一个 bean 实 |
| initialization      | init-method     | 在 bean 的所有必需的属性被容器设置之后，调用回调方法         |
| destruction         | destroy-method  | 当包含该 bean 的容器被销毁时，使用回调方法                   |

#### 2.3 Bean作用域

| 参数           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| singleton      | 在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，**默认值** |
| prototype      | 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean() |
| request        | 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境 |
| session        | 同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境 |
| global-session | 一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境 |

#### 2.4 Bean生命周期

> 为了定义安装和拆卸一个 bean，我们只要声明带有 **init-method** 和/或 **destroy-method** 参数的 。

- init-method 属性指定一个方法，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法，只有从容器中移除 bean 之后，才能调用该方法。
- Bean的生命周期可以表达为：Bean的定义--->Bean的初始化--->Bean的使用--->Bean的销毁
- 当有太多具有相同名称的初始化或者销毁方法的 Bean，无需在每一个 bean 上声明初始化方法和销毁方法。框架使用元素中的 **default-init-method** 和 **default-destroy-method** 属性。

#### 2.5 Bean后置处理器

- Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理。
- **BeanPostProcessor** 接口定义回调方法，你可以实现该方法来提供自己的实例化逻辑，依赖解析逻辑等。
- 我们可以在 Spring 容器通过插入一个或多个 BeanPostProcessor 的实现来完成实例化，配置和初始化一个bean之后实现一些自定义逻辑回调方法。
- 同时通过设置 BeanPostProcessor 实现的 Ordered 接口提供的 order 属性来控制这些 BeanPostProcessor 接口的执行顺序。
- **ApplicationContext** 会自动检测由 BeanPostProcessor 接口的实现定义的 bean，注册这些 bean 为后置处理器，然后通过在容器中创建 bean，在适当的时候调用它。

#### 2.6 Bean定义继承

- 继承

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
 
     <bean id="helloWorld" class="com.tutorialspoint.HelloWorld">
        <property name="message1" value="Hello World!"/>
        <property name="message2" value="Hello Second World!"/>
     </bean>
 
     <bean id="helloIndia" class="com.tutorialspoint.HelloIndia" parent="helloWorld">
        <property name="message1" value="Hello India!"/>
        <property name="message3" value="Namaste India!"/>
     </bean>
 
  </beans>
  ```

- 模板

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
 
     <bean id="beanTeamplate" abstract="true">
        <property name="message1" value="Hello World!"/>
        <property name="message2" value="Hello Second World!"/>
        <property name="message3" value="Namaste India!"/>
     </bean>
 
     <bean id="helloIndia" class="com.tutorialspoint.HelloIndia" parent="beanTeamplate">
        <property name="message1" value="Hello India!"/>
        <property name="message3" value="Namaste India!"/>
     </bean>
 
  </beans>
  ```

  父 bean 自身不能被实例化，因为它是不完整的，而且它也被明确地标记为抽象的。当一个定义是抽象的，它仅仅作为一个纯粹的模板 bean 定义来使用的，充当子定义的父定义使用。

 

### 3. Spring 依赖注入

> Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系。

#### 3.1 基于构造函数的依赖注入

假设你有一个包含文本编辑器组件的应用程序，并且你想要提供拼写检查：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <!-- Definition for textEditor bean -->
   <bean id="textEditor" class="com.tutorialspoint.TextEditor">
      <constructor-arg ref="spellChecker"/>
   </bean>

   <!-- Definition for spellChecker bean -->
   <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
   </bean>

</beans>
```

如果存在不止一个参数时，当把参数传递给构造函数时，可能会存在歧义。要解决这个问题，那么构造函数的参数在 bean 定义中的顺序就是把这些参数提供给适当的构造函数的顺序就可以了：

```java
package x.y;
public class Foo {
   public Foo(Bar bar, Baz baz) {
      // ...
   }
}
```

```xml
<beans>
   <bean id="foo" class="x.y.Foo">
      <constructor-arg ref="bar"/>
      <constructor-arg ref="baz"/>
   </bean>

   <bean id="bar" class="x.y.Bar"/>
   <bean id="baz" class="x.y.Baz"/>
</beans>
```

#### 3.2 基于设值函数的依赖注入

#### 3.3 注入内部 Beans

#### 3.4 注入集合



### 4. Spring  自动装配

> Spring 容器可以在不使用`<constructor-arg>`和`<property>` 元素的情况下**自动装配**相互协作的 bean 之间的关系，这有助于减少编写一个大的基于 Spring 的应用程序的 XML 配置的数量。

#### 4.1 自动装配模式

| 模式        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| no          | 这是**默认**的设置，它意味着没有自动装配，你应该使用显式的bean引用来连线。 |
| byName      | 由**属性名**自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byName。然后尝试匹配，并且将它的属性与在配置文件中被定义为相同名称的 beans 的属性进行连接。 |
| byType      | 由**属性数据类型**自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byType。然后如果它的类型匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。如果存在不止一个这样的 bean，则一个致命的异常将会被抛出。 |
| constructor | 类似于 byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的 bean，则一个致命错误将会发生。 |
| autodetect  | 首先尝试通过 constructor 使用自动装配来连接，如果它不执行，再尝试通过 byType 来自动装配。 |

#### 4.2 自动装配的局限性

- 从写的可能性：使用总是重写自动装配的 <constructor-arg>和 <property> 设置来指定依赖关系；
- 原始数据类型：不能自动装配所谓的简单类型包括基本类型，字符串和类；
- 混乱的本质：自动装配不如显式装配精确，所以如果可能的话尽可能使用显式装配。



### 5. 基于注解的配置

> 从 Spring 2.5 开始就可以使用注解来配置依赖注入，注解连线在默认情况下在 Spring 容器中不打开，因此，在可以使用基于注解的连线之前我们将需要在Spring 配置文件中启用它。

```xml
<beans xmlns="http://www.springframework.org/schema/beans">

   <context:annotation-config/>
   <!-- bean definitions go here -->

</beans>
```

| 注解                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| @Required           | 应用于 bean 属性的 setter 方法                               |
| @Autowired          | 应用到 bean 属性的 setter 方法，非 setter 方法，构造函数和属性 |
| @Qualifier          | 通过指定确切的将被连线的 bean，@Autowired 和 @Qualifier 注解可用于删除混乱 |
| JSR-250 Annotations | Spring 支持 JSR-250 的基础的注解，其中包括了 @Resource，@PostConstruct 和 @PreDestroy 注解 |

#### 5.1 @Required

- **@Required** 注释应用于 bean 属性的 setter 方法，它表明受影响的 bean 属性在配置时必须放在 XML 配置文件中，否则容器就会抛出一个 BeanInitializationException 异常。

#### 5.2 @Autowired

- 当 Spring遇到一个在 setter 方法中使用的 **@Autowired** 注释，它会在方法中视图执行 byType 自动连接。
- 当在属性中使用 **@Autowired** 注释时候，Spring 会将这些传递过来的值或者引用自动分配给那些属性。
- 一个构造函数 **@Autowired** 说明当创建 bean 时，即使在 XML 文件中没有使用 元素配置 bean ，构造函数也会被自动连接。
- 默认情况下，**@Autowired** 注释意味着依赖是必须的，它类似于 @Required 注释，然而，你可以使用 @Autowired 的 **（required=false）** 选项关闭默认行为。

#### 5.3 @Qualifier

- 可能会有这样一种情况，当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 **@Qualifier**注释和 **@Autowired** 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。

#### 5.4 @Cacheable

@Cacheable 的作用 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存。

@Cacheable(value=”accountCache”)，这个注释的意思是，当调用这个方法的时候，会从一个名叫 accountCache 的缓存中查询，如果没有，则执行实际的方法（一般是查询数据库），并将执行的结果存入缓存中，否则返回缓存中的对象。

#### 5.5 JSR-250 注释

- 使用 **@PostConstruct** 注释作为初始化回调函数的一个替代，**@PreDestroy** 注释作为销毁回调函数的一个替代；
- 在字段中或者 setter 方法中使用 **@Resource** 注释，它和在 Java EE 5 中的运作是一样的。

#### 5.6 基于Java 的配置

**@Componen 和 @Bean**

- @Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。
- @Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。

两者的目的是一样的，都是注册bean到Spring容器中。

#### 5.7 Spring 中的事件

| 内置事件              | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| ContextRefreshedEvent | ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生。 |
| ContextStartedEvent   | 当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 |
| ContextStoppedEvent   | 当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。 |
| ContextClosedEvent    | 当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。 |
| RequestHandledEvent   | 这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。 |

- 由于 Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。因此，如果事件处理被使用，在设计应用程序时应注意。



### 6. AOP

> 面向切面编程—>oop

**通知（Advice）**

通知是切面的工作，定义了切面需要何时完成何事。

Spring切面可以应用5种类型的通知：

1. 前置通知（Before）:在目标方法调用之前调用通知功能
2. 后置通知（After）:在目标方法调用之后调用通知，此时不会关心方法输出什么内容
3. 返回通知（After-returning）：在目标方法成功执行后调用通知
4. 异常通知（After-throwing）：在目标方法抛出异常后调用通知
5. 环绕通知（）：通知包裹了被通知的方法，被通知的方法调用前后执行自定义的行为

**连接点（Join Point）**

连接点是应用执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时、甚至时修改一个字段的时候。

**切点（Pointcut）**

切点定义切面的位置，会匹配通知所要织入的一个或多个连接点。

**切面（Aspect）**

切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——在何时何地完成何功能。

**引入（Introduction）**

引入允许我们向现有的类添加新的方法或属性。

**织入（Weaving）**

织入是把切面应用到目标对象并创建新的代理对象的过程。



### 7. 事务



### 8. Spring Security

Spring Security 是基于Spring应用程序提供声明式安全保护的安全性框架，能够在web请求级别和方法调用级别处理身份认证和授权。

**安全模块**

| 模块          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| ACL           | 通过访问控制列表（Access Control List）对域对象提供安全性    |
| Aspects(切面) | 当Security使用注解时，会使用介于Aspects的切面，而非AOP       |
| CAS客户端     | 提供与Jasig的中心认证服务（Central Authentication Service ）进行集成 |
| Configuration | 通过XML和Java配置Spring Security的功能                       |
| Core          | 基本库                                                       |
| Crytography   | 提供加密和密码编码的功能                                     |
| LDAP          | 支持基于LDAP进行认证                                         |
| OpenID        | 支持使用OpenID进行集中式认证                                 |
| Remoting      | 提供对Spring Remoting的支持                                  |
| Tag Library   | JSP标签库                                                    |
| Web           | 基于Filter的Web安全性支持                                    |

- 应用程序类路径下至少包含Core和Configuration两个模块，一般还需Web和JSP的模块



## Ⅱ SpringMVC

### 1. 基本配置

**spring配置**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/cache"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">

    <!--组件扫描-->
    <context:component-scan base-package="com.enosh.study.springstudy" />

    <!--配置视图解析器-->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="WEB-INF/views/"/>
        <property name="suffix" value=".jsp"/>
    </bean>

    <!--开启springMVC框架注解的支持-->
    <mvc:annotation-driven/>
</beans>
```

**springMVC配置**

```xml
<web-app>
    <display-name>Archetype Created Web Application</display-name>

    <!--Spring配置文件路径-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>

    <!--配置解决中文乱码的过滤器-->
    <filter>
        <filter-name>characterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>characterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
   
    <!--Spring上下文监听器,读取其他 XML 配置文件-->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!--配置前端控制器-->
    <servlet>
        <servlet-name>SpringStudy</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
        <!--当值小于0或者没有指定时，则表示容器在该servlet被选择时才会去加载。-->
        <!--正数的值越小，该servlet的优先级越高，应用启动时就越先加载。-->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>SpringStudy</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>

```



### 2. 参数绑定

- 基本类型
- 实体类型
- 集合类型

**自定义类型转换器**

1. 实现`Coverter<S,T>`接口

2. 在spring配置中注册自定义转换器

   ```xml
    <bean id="conversion" class="org.springframework.context.support.ConversionServiceFactoryBean">
           <property name="converters">
               <set>
                   <bean class="com.enosh.study.springstudy.AppInitializer" />
               </set>
           </property>
       </bean>
   ```



### 3. 常用注解

**@RequestMapping**

- `value`：用于指定请求的url，和path属性的作用一致
- `method`：用于指定请求的方法
- `params`：用于指定限制请求参数的条件，要求key-value和配置的一模一样
- `headers`：用于指定限制请求消息头的条件

**@RequestParam**

把请求中指定名称的参数给控制器的形参赋值。

- `value`：请求中的参名称
- `required`：请求中是否必须含有此参数，默认值为true

**@RequestBody**

用于获取请求体内容，直接得到`key=value&key=value...`内容。（GET请求不适用）

- `required`：是否必须有请求体，默认true

**@PathVariable**

用于绑定url中的占位符。

- `value`：占位符名称
- `required`：是否必须提供z占位符

**HiddentHttpMethodFilter过滤器**

由于浏览器只能发送GET和POST请求，HiddentHttpMethodFilter可以将浏览器请求修改为指定的请求方式。

**@RequestHeader**

用于获取请求消息头。（不常用）

- `value`：消息头名称
- `required`：

**@CookieValue**

用于把指定cookie名称的值传入控制器方法参数。

- `value`：
- `required`：

**@ModelAttribute**

用于修饰方法时，表示当前方法会在控制器方法执行之前先执行。（方法可以返回值）；

用于修饰参数时，获取指定的数据给参数赋值。

- `value`：用于获取数据的key

**@SessionAttribute**

用于多次执行控制器方法间的共享。

- `value`：用于指定存入属性的名称
- `type`：用于指定存入属性的类型



### 4. 注解启动

#### 4.1 配置

**配置前端控制器**

```java
public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer{
   
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{RootConfig.class};
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{WebConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

**配置MVC**

```java
@Configuration
@EnableWebMvc
@ComponentScan(basePackages = {"com.enosh.study.mvc.controller"})
public class WebConfig implements WebMvcConfigurer {

    //  配置默认的defaultServlet处理
    // <mvc:default-servlet-handler/>
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        // 配置静态资源处理
        configurer.enable("default");
        //对静态资源的请求转发到容器缺省的servlet，而不使用DispatcherServlet
    }

    /**
     * 静态资源访问控制：假如defaultServlet 没有过滤到接收的静态资源是会报404的
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/statics/**").addResourceLocations("/statics/");
    }

    /**
     * 配置jsp视图解析器
     */
    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");
        return resolver;
    }
}

```

网上教程大多使用`WebMvcConfigurerAdapter`类，但已经过时。

**配置Spring**

```java
@Configuration
@ComponentScan(basePackages = "com.enosh.study.mvc",excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION ,classes = {Controller.class})})
public class RootConfig {
}
```

#### 4.2 原理

在Servlet 3.0环境中，容器会在类路径中查找实现`javax.servlet.ServletContainerInitializer`接口的类，如果能发现的话，就会用它来配置Servlet容器。

Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring 3.2引入了一个WebApplicationInitializer基础实现，也就是AbstractAnnotationConfigDispatcherServletInitializer。



# 四、数据库

## Ⅰ MySQL

### 1. 基本用法

#### 1.1 CRUD

**查询数据（select）**

```mysql
SELECT
    column_1, column_2, ...
FROM
    table_1
[INNER | LEFT |RIGHT] JOIN table_2 ON conditions
WHERE
    conditions
GROUP BY column_1
HAVING group_conditions
ORDER BY column_1
LIMIT offset, length;
```

- `SELECT`之后是逗号分隔列或星号(`*`)的列表，表示要返回所有列
- `FROM`指定要查询数据的表或视图
- `JOIN`根据某些连接条件从其他表中获取数据
- `WHERE`过滤结果集中的行
- `GROUP BY`将一组行组合成小分组，并对每个小分组应用聚合函数
- `HAVING`过滤器基于`GROUP BY`子句定义的小分组
- `ORDER BY`指定用于排序的列的列表
- `LIMIT`限制返回行的数量

（`SELECT`和`FROM`语句是必须的，其他部分可选）



**选择数据（where）**

| 操作符       | 描述                                    |
| ------------ | --------------------------------------- |
| `=`          | 等于，几乎任何数据类型都可以使用它。    |
| `<>` 或 `!=` | 不等于                                  |
| `<`          | 小于，通常使用数字和日期/时间数据类型。 |
| `>`          | 大于，                                  |
| `<=`         | 小于或等于                              |
| `>=`         | 大于或等于                              |

- `BETWEEN`选择在给定范围值内的值
- `LIKE`匹配基于模式匹配的值
- `IN]`指定值是否匹配列表中的任何值
- `IS NULL`检查该值是否为`NULL`



**插入数据（insert）**

`INSERT`语句允许您将一行或多行插入到表中：

```mysql
INSERT INTO table(column1,column2...)
VALUES (value1,value2,...);

#多行插入
INSERT INTO table(column1,column2...)
VALUES (value1,value2,...),
       (value1,value2,...),
...;
```

如果为表中的所有列指定相应列的值，则可以忽略`INSERT`语句中的列列表：

```mysql
INSERT INTO table
VALUES (value1,value2,...);
```

在MySQL中，可以使用`SELECT`语句返回的列和值来填充`INSERT`语句的值：

```mysql
INSERT INTO table_1
SELECT c1, c2, FROM table_2;
```

在`INSERT`语句中指定`ON DUPLICATE KEY UPDATE`选项，MySQL将插入新行或使用新值更新原行记录。



**更新数据（update）**

```mysql
UPDATE [LOW_PRIORITY] [IGNORE] table_name
# LOW_PRIORITY修饰符指示UPDATE语句延迟更新，直到没有从表中读取数据的连接
# 即使发生错误，IGNORE修饰符也可以使UPDATE语句继续更新行。导致错误(如重复键冲突)的行不会更新。
SET
    column_name1 = expr1,
    column_name2 = expr2,
    ...
WHERE
    condition;
```

- 在`UPDATE`关键字后面指定要更新数据的表名。
- `SET`子句指定要修改的列和新值。要更新多个列，请使用以逗号分隔的列表。以字面值，表达式或子查询的形式在每列的赋值中来提供要设置的值。
- 使用`WHERE`子句中的条件指定要更新的行。`WHERE`子句是可选的。 如果省略`WHERE`子句，则`UPDATE`语句将更新表中的所有行。

```mysql
# 为每个客户安排一个销售代表
UPDATE customers
SET
    salesRepEmployeeNumber = (SELECT
            employeeNumber
        FROM
            employees
        WHERE
            jobtitle = 'Sales Rep'
        LIMIT 1)
WHERE
    salesRepEmployeeNumber IS NULL;
```



**删除数据（delete）**

```mysql
DELETE FROM table_name
WHERE condition
ORDER BY c1, c2, ...
LIMIT row_count;
```

#### 1.2 数据库

```mysql
# 创建数据库
CREATE DATABASE [IF NOT EXISTS] database_name;

# 显示数据库
SHOW DATABASES

# 使用数据库
USE database_name;

# 删除数据库
DROP DATABASE [IF EXISTS] database_name;
```

#### 1.3 创建表

```mysql
CREATE TABLE [IF NOT EXISTS] table_name(
        column_list
) engine=table_type;
```

- `column_list`部分指定表的列表。字段的列用逗号(`，`)分隔；
- 需要为`engine`子句中的表指定存储引擎(如：*InnoDB*，*MyISAM*，*HEAP*，*EXAMPLE*，*CSV*，*ARCHIVE*，*MERGE*， *FEDERATED*或*NDBCLUSTER*)。默认使用*InnoDB*。

```mysql
column_name data_type[size] [NOT NULL|NULL] [DEFAULT value] [AUTO_INCREMENT]
```

- `column_name`指定列的名称。每列具有特定数据类型和大小，例如：`VARCHAR(255)`。
- `NOT NULL`或`NULL`表示该列是否接受`NULL`值。
- `DEFAULT`值用于指定列的默认值。
- `AUTO_INCREMENT`指示每当将新行插入到表中时，列的值会自动增加。每个表都有一个且只有一个`AUTO_INCREMENT`列。

```mysql
CREATE TABLE IF NOT EXISTS tasks (
  task_id INT(11) NOT NULL AUTO_INCREMENT,
  subject VARCHAR(45) DEFAULT NULL,
  start_date DATE DEFAULT NULL,
  end_date DATE DEFAULT NULL,
  description VARCHAR(200) DEFAULT NULL,
  PRIMARY KEY (task_id)
) ENGINE=InnoDB;
```

#### 1.4 修改表

可以使用`ALTER TABLE`语句来更改现有表的结构。

**添加列**

```mysql
ALTER TABLE tasks
ADD COLUMN complete DECIMAL(2,1) NULL
AFTER description;
```

**修改列**

```mysql
ALTER TABLE tasks
CHANGE COLUMN task_id task_id INT(11) NOT NULL AUTO_INCREMENT;
```

**删除列**

```mysql
ALTER TABLE tasks
DROP COLUMN description;
```

**重命表名**

```mysql
ALTER TABLE tasks
RENAME TO work_items;
```

或

```mysql
RENAME TABLE old_table_name TO new_table_name;
```

#### 1.5 备份还原

**备份**

```mysql
mysqlump -u <username> -p <password> <database_name> ><path>
```

**还原**

```mysql
source <path>;
```



### 2. 高阶技巧

#### 2.1 多表查询

**笛卡尔积**

```mysql
select * from A, B;
```

**内连接**

- 隐式内连接：使用`where`条件消除无效数据

```mysql
select * from A a, B b where a.id=b.id;
```

- 显示内连接

```mysql
select * from A [inner] join B on A.id = B.id;
```

**外连接**

- 左连接

```mysql
select * from A left [outer] join B on A.id =B.id ;
```

- 右连接

```mysql
select * from A right [outer] join B on A.id =B.id ;
```

左右连接无本质区别，一般习惯使用左连接。

#### 2.2 事务

一个含多个步骤的业务被事务管理，这些步骤要么一起完成，否则一起失败。

```mysql
#开启事务
start trasaction;
#提交shiw
commit；
#回滚事务
rollback;
```

MySQL默认提交事务：一条DML（增删改）语句会自动提交一次事务。

```mysql
#查看事务默认提交方式
select @@autocommit;  # 1代表自动提交
#修改默认提交方式
set @@autocommit =0 ;
```

**事务的四大特征（ACID）**

| 特征                  | 描述                                         |
| --------------------- | -------------------------------------------- |
| 原子性（Atomicity）   | 事务时不可分割的最小单位，同时成功或同时失败 |
| 持久性（Consistency） | 当事务提交或回滚后，数据库会持久化的保存数据 |
| 隔离性（Isolation）   | 多个事务之间相互独立                         |
| 一致性（Durability）  | 事务操作前后，数据总量不变                   |

**事务的隔离级别**

事务时具有隔离性的，但当多个事务操作同一数据时，会引发一些问题，设置不同的隔离级别可以解决。

引发的问题：

1. 脏读：一个事务读取到另一个事务没有提交的数据；
2. 不可重复读（虚读）：在同一事务中，两次读取的数据不一致；
3. 幻读：某一次的DML操作得到的结果所表征的数据状态无法支撑后续的业务操作。

| 隔离级别                     | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

**管理事务隔离级别**

```mysql
#查询数据库事务隔离级别
select @@tx_isolaion;

#修改数据库事务隔离级别
set tx_isolation='read-committed';
#or
set global transaction isolation level <级别字符串>;
```

#### 2.3 CET

> 公共表表达式是一个命名的临时结果集，仅在单个SQL语句(例如`SELECT`，`INSERT`，`UPDATE`或`DELETE`)的执行范围内存在。

```mysql
WITH cte_name (column_list) AS (
    query
)
SELECT * FROM cte_name;

# 实例
WITH customers_in_usa AS (
    SELECT
        customerName, state
    FROM
        customers
    WHERE
        country = 'USA'
) SELECT
    customerName
 FROM
    customers_in_usa
 WHERE
    state = 'CA'
 ORDER BY customerName;
 # CTE的名称为customers_in_usa，定义CTE的查询返回两列：customerName和state。
 # 因此，customers_in_usa CTE返回位于美国的所有客户。
```

**递归CET**

#### 2.4 三大范式

**第一范式（1NF）**

每一列都是不可分割的原子数据项

**第二范式（2NF)**

在1NF的基础上，非码属性必须完全依赖于候选码。（即消除非主属性对主码 的部分函数依赖）

- **函数依赖**：A-->B，如果通过A属性（属性蔟）的值可以确定唯一B属性的值，则B依赖于A
- **完全函数依赖**：A-->B，如果A是一个属性组，则确定B属性的值需要A中所有的属性
- **部分函数依赖**：A-->B，如果A是一个属性组，则确定B属性的值需要A中部分属性
- **传递函数依赖**：A-->B，B-->C，则A-->C
- **码**：如果一张表中的某一属性或属性组被其余属性完全依赖，则称该属性（属性组）为该表的码

**第三范式（3NF）**

在2NF的基础上，任何非主属性不依赖其它非主属性。（即消除传递依赖）

## Ⅱ JDBC

### 1. 简介

- **概念**：Java Database Connectivity
- **本质**：是官方（sun公司）定义的一套操作所有关系型数据库的规则接口，并由数据库厂商去实现这套接口，提供数据库驱动的jar包。

我们可以使用这套接口（JDBC）去编程，而真正执行的代码是驱动中的实现类。（多态）

### 2. 快速入门

```java
public class TestJdbc {
    public static void main(String[] args) throws Exception {
        //1. 注册驱动
        Class.forName("com.mysql.jdbc.Driver");

        //2. 获取连接对象
        Connection conn =DriverManager.getConnection("jdbc:mysql://localhost:3306/zmall?useSSL=false","root","password");

        //3. SQL
        String sql ="update user set role=0 where username=\"admin\"";

        //4. 获取执行SQL对象
        Statement stmt=conn.createStatement();

        //5. 执行sql
        int count= stmt.executeUpdate(sql);

        System.out.println(count);

        //6. 释放资源
        stmt.close();
        conn.close();
    }
}
```



### 3. 常用类

#### 3.1 DriverManager

> 驱动管理对象

**1. 注册驱动**

上面程序使用`Class.forName("com.mysql.jdbc.Driver")`注册驱动，是因为Driver类中含有一个静态代码块，调用DriverManager的**registerDriver**的方法注册驱动。

```java
//Driver源码
static {
    try {
        DriverManager.registerDriver(new Driver());
    } catch (SQLException var1) {
        throw new RuntimeException("Can't register driver!");
    }
}
```

同时，5.x版本之后可以省略注册驱动的步骤，这是因为在驱动jar包中包含一个`META-INF\services\java.sql.Driver`文件，可以帮助我们自动注册驱动。

**2. 获取数据库连接**

```java
static Connection getConnection(String url, String user, String password);
```

#### 3.2 Connection

> 数据库连接对象

**1. 获取执行SQL的对象**

```java
Statement createStatement() throws SQLException;

PreparedStatement prepareStatement(String sql)throws SQLException;
```

**2. 管理事务**

```java
//开启事务，设置参数为false开启事务
void setAutoCommit(boolean autoCommit) throws SQLException;

//提交事务
void commit() throws SQLException;

//事务回滚
void rollback() throws SQLException;
```

#### 3.3 Statement

> 执行SQL的对象，执行静态SQL语句并返回运算结果

```java
//执行任意的SQL（不常用）
boolean execute(String sql) throws SQLException;

//执行DML（增删改）、DDL（创建）语句，并返回影响行数
int executeUpdate(String sql) throws SQLException;

//执行DQL(查询)语句
ResultSet executeQuery(String sql) throws SQLException;
```

#### 3.4 ResultSet

> 结果集对象

- **next()**：游标向下移动一行；

```java
boolean next() throws SQLException;
```

- **getXxx(param)**：获取数据。

其中参数<int>代表参数列的标号，从1开始；<String>类型代表列的名称。

```java
Connection conn= DriverManager.getConnection("jdbc:mysql:///zmall?useSSL=false","root","password");

Statement stmt=conn.createStatement();
String sql="select * from user";

ResultSet rs=stmt.executeQuery(sql);

while (rs.next()){
    System.out.print("username: "+rs.getString("username")+" password: ");
    System.out.println(rs.getString("password"));
}
```

#### 3.5 PreparedStatement

> 继承Statement，执行预编译的SQL语句

**1. 解决SQL注入问题**

```java
//SQL的参数使用占位符`?`
String sql="select * from user where username=? and password=?";
//获取对象
PreparedStatement pstmt=conn.prepareStatement(sql);
//传递参数，以1开始
pstmt.setString(1,"admin");
pstmt.setString(2,"admin");
//执行SQL语句
ResultSet rs=pstmt.executeQuery();
```



### 4. 事务控制

```java
 public static void main(String[] args){
        Connection conn=null;
        try {
            conn= DriverManager.getConnection("jdbc:mysql:///zmall?useSSL=false"
                    ,"root","password");

            //开启事务
            conn.setAutoCommit(false);

            String sql="update user set role = ? where username=?";
            PreparedStatement pstmt1=conn.prepareStatement(sql);
            PreparedStatement pstmt2=conn.prepareStatement(sql);
            //赋值操作，index从1开始
            pstmt1.setString(2,"admin");
            ......
            pstmt1.executeQuery();
            //制造异常
            int a=3/0;
            pstmt2.executeQuery();

            //提交事务
            conn.commit();
        }catch (Exception e){
            //事务回滚
            try {
                if (conn!=null) conn.rollback();    //判断是否存在连接
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
        }
    }
```



### 5. 数据库连接池

> 存放数据库连接的容器（集合），节约资源，高效访问。

- 标准接口：javax.sql包下的 DataSource，包含两个主要方法，获取连接和归还连接；
- 一般由数据库厂家实现，常用的两个数据库连接池技术：C3P0和Druid。

**C3P0**

引入jar包，并配置文件`c3p0.properties`或`c3p0-config.xml`放置类路径下。

```java
//创建连接池，可传参数，选择配置文件中的其他配置
DataSource ds=new ComboPooledDataSource();

//获取连接池
Connection cnn=ds.getConnection();

//归还连接
conn.close();
```

**Druid**

导入jar包，配置文件`druid.properties`。可以是任意名称、任意路径。

```properties
url=jdbc:mysql:///zmall?useSSL=false
driverClassName=com.mysql.jdbc.Driver
username=root
password=root
```

| 属性            | 默认            | 描述                                                         |
| :-------------- | :-------------- | :----------------------------------------------------------- |
| username        |                 | 连接数据库的用户名                                           |
| password        |                 | 连接数据库的密码                                             |
| jdbcUrl         |                 | 同DBCP中的jdbcUrl属性                                        |
| driverClassName | 根据url自动识别 | 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName |
| initialSize     | 0               | 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 |
| maxActive       | 8               | 最大连接池数量(Maximum number of Connections a pool will maintain at any given time) |
| maxIdle         | 8               | 已经不再使用，配置了也没效果                                 |
| minIdle         |                 | 最小连接池数量                                               |
| maxWait         |                 | 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 |

```java
//加载配置
Properties pro=new Properties();
InputStream is=TestDruid.class.getClassLoader().getResourceAsStream("jdbc.properties");
pro.load(is);
//通过工厂创建连接池对象
DataSource ds= DruidDataSourceFactory.createDataSource(pro);
//获取连接
Connection conn=ds.getConnection();
```



### 6. Spring JDBC

> Spring框架对jdbc的简单封装

需要创建JdbcTemplate对象，依赖于数据源DataSource。

```java
dbcTemplate template=new JdbcTemplate(dataSource);
String sql="update user set username=? where id=?";

int count=template.update(sql, "admin", 1);
```

**常用方法**

| 方法名           | 描述                       |
| ---------------- | -------------------------- |
| update()         | 执行增删改语句（DML）      |
| queryForMap()    | 查询结果封装成Map集合      |
| queryForList()   | 查询结果封装成List集合     |
| query()          | 查询结果封装成JavaBean对象 |
| queryForObject() | 查询结果并封装成对象       |



## Ⅲ Redis

### 1. NoSQL

#### 1.1 概述

**背景**：单机MySQL数据存储的瓶颈：数据量的总大小一台机器放不下，数据索引（B+树）一台机器的内存不足，访问量（读写混合）一个实例不够。

解决方案：

- Memcached（缓存）+垂直拆分
- MySQL主从读写分离
- 分库分表+s水平拆分+MySQL集群

**定义**：NoSQL==Not Only SQL，泛指**非关系型数据库**，这些类型的数据存储不需要固定的模式，无需多余的操作就可以横向拓展。

**特定**：易拓展（数据间无关系），大数据量高性能，数据模型灵活多样（增删字段）。

**实现**：Redis，Memcache，Mongdb。

**3V**：海量Volume，多样Variety，实时Velocity。

**3高**：高并发，高可拓，高性能。

#### 1.2 数据模型

- KV键值对
- BSON（文档型数据库）
- 列族（列存储数据库）
- 图形（图关系数据库）

#### 1.3 CAP

- Consistency：强一致性
- Avaliability：可用性
- Partition tolerance：分区容错性

**CAP的核心理论**：一个分布式系统不可能同时满足和好的一致性，可用性和分区容错性这三个需求，最多能够较好的满足两个。因此把NoSQL数据库分成满足CA，CP和AP原则的三大类。

- CA：单点集群，通常在可拓展性上不太强大，传统关系型数据库
- CP：性能不高，Redis、Mongodb
- AP：对一致性要求较低，大多数网站架构的选择

虽说CAP理论可以三选二，但由于当前网络硬件肯定会出现丢包和延迟等问题，所以分区容错性是我们必须实现的。

#### 1.4 BASE

BASE就是为了关系型数据库强一致性而引起可用性降低的解决方案。

- Basically Avaliable：基本可用
- Soft state：软状态
- Eventually consistent：最终一致

#### 1.5分布式与集群

- **分布式**：不同的服务器上面部署不同的服务模块或工程，它们之间通过RPC/RMI通信和调用，对外提供服务和组内合作；
- **集群**：不同的多台服务器部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。

### 2. Redis

远程字典服务器：Remote Dictionary Server。

**作用**

- 内存存储和持久化：支持异步将内存中的数据写到硬盘，同时不影响服务
- 取最新N个数据操作：可将最新的10条评论ID放置Redis的List集合里
- 模拟类似HttpSession这种设定过期时间的功能
- 发布、订阅消息系统
- 定时器、计数器

#### 2.1 数据类型

| 类型              | 描述                                       | 场景                                                         |
| :---------------- | :----------------------------------------- | :----------------------------------------------------------- |
| String（字符串）  | 二进制安全                                 |                                                              |
| Hash（哈希）      | 键值对集合,即编程语言中的Map类型           | 存储、读取、修改用户属性                                     |
| List（列表）      | 链表(双向链表)                             | 最新消息排行等功能(比如朋友圈的时间线) ，消息队列            |
| Set（集合）       | 哈希表实现,元素不重复                      | 共同好友；利用唯一性、统计访问网站的所有独立ip ；好友推荐时，根据tag求交集；大于某个阈值就可以推荐 |
| Zsort（有序集合） | 给元素增加一个权重参数score，并按score排列 |                                                              |

**2.1.1 String**

string是redis最基本的类型，和memcached的模型一样，一个key对应一个value，其中一个value最大512M。

string类型是**二进制安全**的，意思是redis的string可以存放任何数据，包括图片和序列化对象。

**2.1.2 Hash**

Redis 哈希是一个键值对集合，即一个string类型的field和value的映射表，特别适合存储对象。

并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)

**2.1.3 List**

Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。增删快,提供了操作某一段元素的API

列表最多可存储 2^32 - 1 元素 (4294967295, 每个列表可存储40多亿)。

**2.1.4 Set**

Redis set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

为集合提供了求交集、并集、差集等操作。

**2.1.5 Zset**

Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。

#### 2.2 命令

**2.2.1 连接**

连接本地服务器

```cmd
$redis-cli
redis 127.0.0.1:6379> PING
PONG
```

连接远程服务器

```cmd
$redis-cli -h 127.0.0.1 -p 6379 -a "password"
redis 127.0.0.1:6379> PING
PONG

```

有时候会有中文乱码。要在 redis-cli 后面加上 `--raw`参数可以避免中文乱码。

| 序号          | 描述               |
| :------------ | :----------------- |
| AUTH password | 验证密码是否正确   |
| ECHO message  | 打印字符串         |
| PING          | 查看服务是否运行   |
| QUIT          | 关闭当前连接       |
| SELECT index  | 切换到指定的数据库 |

**2.2.2 Key**

| 命令                                 | 描述                                                       |
| :----------------------------------- | :--------------------------------------------------------- |
| del key                              | 该命令用于在 key 存在时删除 key                            |
| dump key                             | 序列化给定 key ，并返回被序列化的值                        |
| exists key                           | 检查给定 key 是否存在                                      |
| expire key seconds                   | 为给定 key 设置过期时间，以秒计                            |
| expireat key timestamp               | 设置过期时间，时间参数是 UNIX 时间戳(unix timestamp)       |
| pexpire key milliseconds             | 设置 key 的过期时间以毫秒计                                |
| pexpireat key milliseconds-timestamp | 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计         |
| keys pattern                         | 查找所有符合给定模式( pattern)的 key                       |
| move key db                          | 将当前数据库的 key 移动到给定的数据库 db 当中              |
| persist key                          | 移除 key 的过期时间，key 将持久保持                        |
| pttl key                             | 以毫秒为单位返回 key 的剩余的过期时间。                    |
| ttl key                              | 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live) |
| randomkey                            | 从当前数据库中随机返回一个 key                             |
| rename key newkey                    | 修改 key 的名称                                            |
| renamenx key newkey                  | 仅当 newkey 不存在时，将 key 改名为 newkey                 |
| type key                             | 返回 key 所储存的值的类型                                  |

#### 2.3 发布订阅

Redis发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。

![](https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png)

| 序号                                       | 描述                             |
| :----------------------------------------- | :------------------------------- |
| PSUBSCRIBE pattern [pattern ...]           | 订阅一个或多个符合给定模式的频道 |
| PUBSUB subcommand [argument [argument ...] | 查看订阅与发布系统状态           |
| PUBLISH channel message                    | 将信息发送到指定的频道           |
| PUNSUBSCRIBE [pattern [pattern ...]]       | 退订所有给定模式的频道           |
| SUBSCRIBE channel [channel ...]            | 订阅给定的一个或多个频道的信息   |
| UNSUBSCRIBE [channel [channel ...]]        | [指退订给定的频道                |

#### 2.4 事务

单个Redis命令的执行是原子性的，但Redis没有在事务上增加任何维持原子性的机制，所以Redis事务的执行并不是原子性的。

| 序号                | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| DISCARD             | 取消事务，放弃执行事务块内的所有命令                         |
| EXEC                | 执行所有事务块内的命令                                       |
| MULTI               | 标记一个事务块的开始                                         |
| UNWATCH             | 取消 WATCH 命令对所有 key 的监视                             |
| WATCH key [key ...] | 监视一个(或多个) key ，如果在事务执行之前这些key被其他命令所改动，那么事务将被打断 |

### 3. 进阶部分

#### 3.1 备份与恢复

**数据备份**

Redis `SAVE` 命令用于创建当前数据库的备份。

```cmd
redis 127.0.0.1:6379> SAVE
```

该命令将在 redis 安装目录中创建dump.rdb文件。

**数据恢复**

如果需要恢复数据，只需将备份文件dump.rdb移动到redis安装目录并启动服务即可。

获取 redis 目录可以使用 `CONFIG`命令：

```cmd
redis 127.0.0.1:6379> CONFIG GET dir
```

 **BGSAVE**

创建 redis 备份文件也可以使用命令`BGSAVE`，该命令在后台执行。

```cmd
127.0.0.1:6379> BGSAVE
Background saving started
```

#### 3.2 管道技术

Redis是一种基于BS模型和请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：

- 客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。
- 服务端处理命令，并将结果返回给客户端。

Redis管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并一次性读取所有服务端的响应。

#### 3.3 分区

分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。

通过利用多台计算机内存的和值，允许构造更大的数据库，方便我们拓展计算能力和网络带宽。

- 通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。
- **范围分区**：最简单的分区方式，就是映射一定范围的对象到特定的Redis实例；
- **哈希分区**：

#### 3.4 JRedis

在Java代码中使用Redis，需要下载redis服务的Java驱动[jredis](https://mvnrepository.com/artifact/redis.clients/jedis)。

```java
public class RedisUtil {
    //服务器IP地址
    private static String ADDR = "192.168.41.65";
    //端口
    private static int PORT = 6379;
    //密码
    private static String AUTH = "123456";
    //连接实例的最大连接数
    private static int MAX_ACTIVE = 1024;
    //控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。
    private static int MAX_IDLE = 200;
    //等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。超时抛出JedisConnectionException
    private static int MAX_WAIT = 10000;
    //连接超时的时间　　
    private static int TIMEOUT = 10000;
    // 在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的；
    private static boolean TEST_ON_BORROW = true;

    private static JedisPool jedisPool = null;
    //数据库模式是16个数据库 0~15
    public static final int DEFAULT_DATABASE = 0;
    //初始化Redis连接池
    static {
        try {
            JedisPoolConfig config = new JedisPoolConfig();
            config.setMaxTotal(MAX_ACTIVE);
            config.setMaxIdle(MAX_IDLE);
            config.setMaxWaitMillis(MAX_WAIT);
            config.setTestOnBorrow(TEST_ON_BORROW);
            jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT,AUTH,DEFAULT_DATABASE);

        } catch (Exception e) {

            e.printStackTrace();
        }
    }
    //获取Jedis实例
    public synchronized static Jedis getJedis() {
        try {
            if (jedisPool != null) {
                Jedis resource = jedisPool.getResource();
                System.out.println("redis--服务正在运行: "+resource.ping());
                return resource;
            } else {
                return null;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    //释放资源
    public static void returnResource(final Jedis jedis) {
            if(jedis != null) {
                jedisPool.returnResource(jedis);
            }
    }
}
```

# 五、VCS

## Ⅰ Git

**VCS**全称Version Control System，是记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。

| 系统                                                       | 简称 | 描述                                                         |
| ---------------------------------------------------------- | ---- | ------------------------------------------------------------ |
| 本地版本控制系统                                           |      | 复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别 |
| 集中化的版本控制系统（Centralized Version Control System） | CVCS | 有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 |
| 分布式版本控制系统（Distributed Version Control System）   | DVCS | 客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来 |

### 1. Git原理

- **直接记录快照，而非差异比较**

其它版本控制系统将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异，存储每个文件与初始版本的差异。

![](http://www.yiibai.com/uploads/images/201707/0607/919150744_33189.png)

Git 不按照以上方式对待或保存数据，为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。

![](http://www.yiibai.com/uploads/images/201707/0607/480150745_86943.png)

- **近乎所有操作本地执行**
- **Git保证完整性**

Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。（Git 用以计算校验和的机制叫做 SHA-1 散列）

- **Git一般只添加数据**
- **三种状态**

| 状态              | 描述                                                       |
| ----------------- | ---------------------------------------------------------- |
| 已提交(committed) | 表示数据已经安全的保存在本地数据库中                       |
| 已修改(modified)  | 表示修改了文件，但还没保存到数据库中                       |
| 已暂存(staged)    | 表示对一个已修改文件的版本做了标记，使之在下次提交的快照中 |

同时引入 Git 项目的三个工作区域的概念

| 工作区   | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| Git 仓库 | 是 用来保存项目的元数据和对象数据库的地方。                  |
| 工作目录 | 是对项目的某个版本独立提取出来的内容，放在磁盘上供你使用或修改 |
| 暂存区域 | 是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中 |

**基本的 Git 工作流程如下**：

1. 在工作目录中修改文件。
2. 暂存文件，将文件的快照放入暂存区域。
3. 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。

### 2. Git快速入门

> https://www.yiibai.com/git/git-quick-start.html

- **获取Git仓库**

1. 获取 Git 仓库：`git clone`
2. 现有目录中初始化仓库：`git init`

- **更新提交到仓库**

1. 检查当前文件状态：`git status`
2. 实现对文件的追踪：`git add`（可以使用文件或目录的路径作为参数）
3. 状态简览：`git status -s`或`git status --short`
4. 忽略文件：``
5. 查看已暂存和未暂存的修改：`git diff`
6. 提交更新：`git commit`或`git commit -m`
7. 跳过使用暂存区域：`git commit -a -m`（把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤）
8. 移除文件：`git rm`
9. 移动文件：`git mv`

- **查看历史提交版本**

1. 查看历史提记录：``git log` `

- **撤销操作**

1. 尝试重新提交信息：`git commit --amend`
2. 取消暂存的文件：`git reset HEAD <file>...`
3. 撤消对文件的修改：`git checkout -- <file>`

- **远程仓库的使用**

1. 查看远程服务器：`git remote`（指定选项 `-v`，会显示读写远程仓库的 Git 保存的简写与其对应的 URL）
2. 添加远程仓库：`git remote add <shortname> <url>`（可以使用`<shortname>`代替`<url>`）
3. 从远程仓库中抓取与拉取：`git fetch [remote-name]`（命令会将数据拉取到本地仓库 - 它并不会自动合并或修改当前的工作）
4. 自动的抓取然后合并远程分支到当前分支：`git pull`
5. 推送到远程仓库：`git push [remote-name] [branch-name]`（只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。）
6. 查看远程仓库：`git remote show [remote-name]`
7. 重命名仓库引用的名字：`git remote rename [oldname] [newname]`
8. 移除一个远程仓库：`git remote rm [remote-name]`

### 3. Git隐藏(Stash)操作

- 要切换分支以进行客户升级，但不想提交一直在做的工作; 那么可以把当前工作的改变隐藏起来。 要将一个新的存根推到堆栈上，运行`git stash`命令；
- 现在，可以安全地切换分支并在其他地方工作。通过使用`git stash list`命令来查看已存在更改的列表；
- 想要重新开始新的功能的代码编写，查找上次没有写完成的代码，只需执行`git stash pop`命令即可从堆栈中删除更改并将其放置在当前工作目录中。

### 4. Git修正错误

**恢复未提交的更改**

假设我们不小心修改了本地存储库中的一个文件，此时想撤销这些修改。为了处理这种情况，我们可以使用`git checkout`命令。可以使用此命令来还原文件的内容。

`git checkout`命令还可以从本地存储库获取已删除的文件。假设我们从本地存储库中删除一个文件，我们想要恢复这个文件。那么可以通过使用`git checkout`命令来实现这一点。

**删除分段区域的更改**

`git checkout head -- string.py`

**用Git复位移动头指针**

经过少量更改后，可以决定删除这些更改。 `git reset`命令用于复位或恢复更改。

- `--soft`选项：每个分支都有一个`HEAD`指针，它指向最新的提交。它将仅重置`HEAD`指针而不会破坏任何东西；
- `--mixed`选项：将从尚未提交的暂存区域还原这些更改，对文件的工作副本进行的实际更改不受影响；
- `--hard`选项：它会清除分段区域，将HEAD指针重置为特定提交ID的最新提交，并删除本地文件更改。

### 5. Git标签操作

**创建标签**

使用`git tag`命令来标记当前`HEAD`指针。

在创建标签时需要提供`-a`选项指定标签名称，并提供带`-m`选项指定标签消息。

**查看标签**

可以使用带有`-l`选项的`git tag`命令查看所有可用的标签。即`git tag -l`

可使用`git show`命令后跟其标签名来查看有关标签的更多详细信息。

**删除标签**

使用 带有`-d`选项 删除标签：`git tag -d [tag-name]`

### 6. Git补丁操作

**创建补丁**

我们使用`git format-patch`命令创建最新提交的修补程序。 如果要为特定提交创建修补程序，请在`format-patch`命令后面指定 `COMMIT_ID` 。(此命令会在当前工作目录中创建`.patch`文件)

**应用补丁**

其他开发人员可以使用这个补丁来修改他的文件。 Git分别提供两个命令：`git am` 和 `git apply` 来应用补丁。 （`git apply`修改本地文件而不创建提交，而`git am`会修改文件并创建提交）

### 7. Git管理分支

> 分支操作允许创建另一路线/方向上开发。我们可以使用这个操作将开发过程分为两个不同的方向。 例如，我们发布了`1.0`版本的产品，可能需要创建一个分支，以便将`2.0`功能的开发与`1.0`版本中错误修复分开。

**创建分支**

使用`git branch [branch name]`命令创建一个新的分支。可以从现有的分支创建一个新的分支。 也可以使用特定的提交或标签作为起点创建分支。 （默认将以`HEAD`作为起点来创建分支）

**查看分支**

使用`git branch`命令列出可用的分支。

**切换分支**

使用`git checkout`命令在分支之间切换。

其中Git为`checkout`命令提供`-b`选项：此操作将创建一个新的分支，并立即切换到新分支。

**删除分支**

可以通过向`git branch`命令提供`-D`选项来删除分支。 但在删除现有分支之前，请切换到其他分支。

**重命名分支**

那么可通过使用`git branch`命令的`-m`选项后跟旧的分支名称和新的分支名称来更改/重新命名分支名称。

**合并两个分支**

`git merge origin/new_branch`

测试后，就可将代码更改推送到`master`分支了：`git push origin master`

### 8. Git不同平台换行符问题

GNU/Linux和Mac OS使用换行(`LF`)或新行作为行结束字符，而Windows使用换行和回车(`LFCR`)组合来表示行结束字符。为了避免这些行结尾的差异的不必要提交，我们必须配置Git客户端写入与Git仓库使用相同的行结束符。

- 对于Windows系统，可以将Git客户端配置为将行结束符转换为`CRLF`格式，同时退出，并在提交操作时将其转换回`LF`格式：` git config --global core.autocrlf true`
- 对于*GNU/Linux*或*Mac OS*，我们可以配置Git客户端，以便在执行结帐操作时将线结束从CRLF转换为LF：`git config --global core.autocrlf input`

### 9. Git远程操作详解

![](https://www.yiibai.com/uploads/allimg/140613/0A025G34-0.jpg)

## Ⅱ Maven

Maven 是一个项目管理和整合工具，为开发者提供了一套完整的构建生命周期框架。

- Maven 使用了一个标准的目录结构和一个默认的构建生命周期
- 无缝衔接了编译、发布、文档生成、团队合作和其他任务

### 1.概述

#### 1.1 POM

> **工程对象模型**：Project Object Model

- 是使用 Maven 的基本组件，位于工程根目录下，是一个名为 pom的 xml 文件
- POM 包含了关于工程和各种配置细节的信息，Maven 使用这些信息构建工程
- POM 也包含了目标和插件

在创建 POM 之前，我们首先确定工程组（groupId），及其名称（artifactId）和版本，这是工程的唯一标识。

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
   http://maven.apache.org/xsd/maven-4.0.0.xsd">
   <modelVersion>4.0.0</modelVersion>

   <!-- 这是工程组的标识。它在一个组织或者项目中通常是唯一的 -->
   <groupId>com.companyname.project-group</groupId>
   <!-- 这是工程的标识。它通常是工程的名称 -->
   <artifactId>project</artifactId>
   <version>1.0</version>

</project>
```

**Super POM**

所有的 POM 都继承自一个父 POM（无论是否显式定义了这个父 POM）。它包含了一些可以被继承的默认设置。

查看 Super POM 默认配置的一个简单方法是执行以下命令：**mvn help:effective-pom**

#### 1.2 构建生命周期

> 构建生命周期是一组阶段的序列（sequence of phases），每个阶段定义了目标被执行的顺序。

一个典型的 Maven 构建生命周期是由以下几个阶段的序列组成的：

| 阶段              | 处理     | 描述                                           |
| ----------------- | -------- | ---------------------------------------------- |
| prepare-resources | 拷贝资源 | 可以自定义需要拷贝的资源                       |
| compile           | 编译     | 完成源代码编译                                 |
| package           | 打包     | 根据 pom.xml 中描述的打包配置创建 JAR / WAR 包 |
| install           | 安装     | 本地 / 远程仓库中安装工程包                    |

#### 1.3 构建配置文件

构建配置文件是一组配置的集合，用来设置或者覆盖 Maven 构建的默认配置。使用构建配置文件，可以为不同的环境定制构建过程，如 Producation 和 Development 环境。

**Profile 类型**

- Per Project：定义在工程 POM 文件 pom.xml 中
- Per User：定义在 Maven 设置 xml 文件中 （%USER_HOME%/.m2/settings.xml）
- Global：定义在 Maven 全局配置 xml 文件中 （%M2_HOME%/conf/settings.xml）

**Profile 激活**

- 显式使用命令控制台输入：**mvn test -Ptest**

```xml
<profiles>
    <profile>
        <id>test</id>
        <build>
        </build>
    </profile>
</profiles>
```

- 通过 maven 设置
- 基于环境变量（用户 / 系统变量）
- 操作系统配置（例如，Windows family）
- 现存 / 缺失 文件

#### 1.4 仓库

> 仓库是一个位置，可以存储所有的工程 jar 文件、library jar 文件、插件或任何其他的工程指定的文件。

**本地仓库（local）**

Maven 本地仓库是本地机器上的一个文件夹，它在你第一次运行任何 maven 命令的时候创建。

```xml
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
   http://maven.apache.org/xsd/settings-1.0.0.xsd">
      <localRepository>C:/MyLocalRepository</localRepository>
</settings>
```

**中央仓库（central）**

Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。

- 这个仓库由 Maven 社区管理。
- 不需要配置。
- 需要通过网络才能访问。

**远程仓库（remote）**

它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。

**Maven 依赖搜索顺序**

本地仓库——>中央仓库——>远程仓库——>停滞处理并抛出error

#### 1.5 插件

> Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成
>
> 插件可以创建 jar 文件，创建 war 文件，编译代码文件，代码单元测试，创建工程文档，创建工程报告

**插件类型**

- **Build plugins**：在构建时执行，并在 pom.xml 的 元素中配置
- **Reporting plugins**：在网站生成过程中执行，并在 pom.xml 的 元素中配置

### 2. 工程

#### 2.1 创建工程

Maven 使用**原型（archetype）**插件创建工程。要创建一个简单的 Java 应用，我们将使用 maven-archetype-quickstart 插件。

1. 从控制台进入工程根目录，键入命令：

```
mvn archetype:generate
```

2. Maven 将开始处理，并将创建完成的 java 应用工程结构

#### 2.2 构建 & 测试工程

- `mvn clean package`
- `mvn clean compile`

#### 2.3 外部依赖

- 在 src 文件夹下添加 lib 文件夹

- 复制任何 jar 文件到 lib 文件夹下

- 同时将依赖库添加到POM中

  ```xml
  <dependency>
      <groupId>ldapjdk</groupId>
      <artifactId>ldapjdk</artifactId>
      <scope>system</scope>
      <version>1.0</version>
      <systemPath>${basedir}\src\lib\ldapjdk.jar</systemPath>
  </dependency>
  ```

**依赖阶段**

- *compile*
  默认scope为compile，表示为当前依赖参与项目的编译、测试和运行阶段，属于强依赖。打包之时，会达到包里去。
- *test*
  该依赖仅仅参与测试相关的内容，包括测试用例的编译和执行，比如定性的Junit。
- *runtime*
  依赖仅参与运行周期中的使用。一般这种类库都是接口与实现相分离的类库，比如JDBC类库，在编译之时仅依赖相关的接口，在具体的运行之时，才需要具体的mysql、oracle等等数据的驱动程序。
  此类的驱动都是为runtime的类库。
- *provided*
  该依赖在打包过程中，不需要打进去，这个由运行的环境来提供，比如tomcat或者基础类库等等，事实上，该依赖可以参与编译、测试和运行等周期，与compile等同。区别在于打包阶段进行了exclude操作。
- *system*
  使用上与provided相同，不同之处在于该依赖不从maven仓库中提取，而是从本地文件系统中提取，其会参照systemPath的属性进行提取依赖。
- *import*
  这个是maven2.0.9版本后出的属性，import只能在dependencyManagement的中使用，能解决maven单继承问题，import依赖关系实际上并不参与限制依赖关系的传递性。

#### 2.4 工程文档

> Maven 使用称作 Doxia 的文件处理引擎创建文档，它将多个源格式的文件转换为一个共通的文档模型。

- 根目录下命令：**mvn site**
- 生成文档在 target\site 文件夹下

#### 2.5工程模板

Maven 使用原型（Archetype）概念为用户提供了大量不同类型的工程模版（614 个），Maven 模板帮助用户快速创建 java 项目。

### 3. 管理

#### 3.1 快照

> **快照**是一个特殊的版本，它表示当前开发的一个副本。与常规版本不同，Maven 为每一次构建从远程仓库中检出一份新的快照版本

**快照 vs 版本**

- 对于版本，Maven 一旦下载了指定的版本（例如 data-service:1.0），它将不会尝试从仓库里再次下载一个新的 1.0 版本。想要下载新的代码，数据服务版本需要被升级到 1.1。
- 对于快照，每次用户接口团队构建他们的项目时，Maven 将自动获取最新的快照（data-service:1.0-SNAPSHOT）。

使用命令强制下载最新快照：**mvn clean package -U**

#### 3.2 管理依赖

> Maven 核心特点之一是依赖管理。一旦我们开始处理多模块工程（包含数百个子模块或者子工程）的时候，模块间的依赖关系就变得非常复杂，Maven 提供了一种高度控制的方法。

**传递依赖发现**

| 功能     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 依赖调节 | 决定当多个手动创建的版本同时出现时，哪个依赖版本将会被使用。 如果两个依赖版本在依赖树里的深度是一样的时候，第一个被声明的依赖将会被使用 |
| 依赖管理 | 直接的指定手动创建的某个版本被使用。如工程 C 在自己的以来管理模块包含工程 B，即 B 依赖于 A， 那么 A 即可指定在 B 被引用时所使用的版本 |
| 依赖范围 | 包含在构建过程每个阶段的依赖                                 |
| 依赖排除 | 任何可传递的依赖都可以通过 "exclusion" 元素被排除在外。举例说明，A 依赖 B， B 依赖 C，因此 A 可以标记 C 为 “被排除的” |
| 依赖可选 | 任何可传递的依赖可以被标记为可选的，通过使用 "optional" 元素。例如：A 依赖 B， B 依赖 C。因此，B 可以标记 C 为可选的， 这样 A 就可以不再使用 C |

**依赖范围**

| 范围     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 编译阶段 | 该范围表明相关依赖是只在工程的类路径下有效。默认取值         |
| 供应阶段 | 该范围表明相关依赖是由运行时的 JDK 或者 网络服务器提供的     |
| 运行阶段 | 该范围表明相关依赖在编译阶段不是必须的，但是在执行阶段是必须的 |
| 测试阶段 | 该范围表明相关依赖只在测试编译阶段和执行阶段                 |
| 系统阶段 | 该范围表明你需要提供一个系统路径                             |
| 导入阶段 | 该范围只在依赖是一个 pom 里定义的依赖时使用。同时，当前工程的POM 文件的 部分定义的依赖关系可以取代某特定的 POM |

**依赖管理**

通常情况下，在一个共通的工程下，有一系列的工程。在这种情况下，我们可以创建一个公共依赖的 pom 文件，该 pom 包含所有的公共的依赖关系，我们称其为其他子工程 pom 的 pom 父。

#### 3.3 自动化部署

- Maven 构建和发布项目，
- SubVersion, 源代码库用以管理源代码，
- 远程仓库管理工具 (Jfrog/Nexus) 用以管理工程的二进制文件。

我们将会使用 Maven 发布的插件来创建一个自动化发布过程：

**Maven Release 插件**

- mvn release:clean：清理工作空间，保证最新的发布进程成功进行
- mvn release:rollback：回滚修改的工作空间代码和配置保证发布过程成功进行
- mvn release:prepare
- mvn release:perform：将代码切换到之前做标记的地方

#### 3.4 Web 应用

- maven-archetype-webapp 插件

### 4. 常用插件

#### 4.1 maven-compiler-plugin

设置maven编译的Jdk版本，用于编译源码。

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.1</version>
    <configuration>
        <source>1.8</source> <!-- 源代码使用的JDK版本 -->
        <target>1.8</target> <!-- 需要生成的目标class文件的编译版本 -->
        <encoding>UTF-8</encoding><!-- 字符集编码 -->
        <skipTests>true</skipTests><!-- 跳过测试 -->
    </configuration>
</plugin>
```

#### 4.2 maven-jar-plugin

打包jar文件时，配置manifest文件，加入lib包的jar依赖。

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <configuration>
        <classesDirectory>target/classes/</classesDirectory>
        <archive>
            <manifest>
                <mainClass>com.alibaba.dubbo.container.Main</mainClass>
                <!-- 打包时 MANIFEST.MF文件不记录的时间戳版本 -->
                <!--自动加载META-INF/spring目录下的所有Spring配置-->
                <useUniqueVersions>false</useUniqueVersions>
                <addClasspath>true</addClasspath>
                <classpathPrefix>lib/</classpathPrefix>
            </manifest> <manifestEntries>
            <Class-Path>.</Class-Path>
            </manifestEntries>
        </archive>
    </configuration>
</plugin>
```

#### 4.3 maven-war-plugin

排除不想打进war包的jar 的配置。

```xml
<plugin> 
    <groupId>org.apache.maven.plugins</groupId> 
    <artifactId>maven-war-plugin</artifactId> 
    <version>2.1-alpha-1</version> 
    <configuration> 
        <!-- 
            打包之前过滤掉不想要被打进 .war包的jar,注意：这个地方，本来路径应该是 
            WEB-INF/lib/anaalyzer-2.0.4.jar,但是经过多次试验,不能这样，
            至于咋回事儿，搞不清楚。。经多方查证均无结果 
            暂且这样吧，虽然显得很丑陋，但是总能解决问题吧 
        --> 
        <warSourceExcludes>*/lib/analyzer-2.0.4.jar</warSourceExcludes> 
        <webResources> 
            <resource> 
                <!-- 元配置文件的目录，相对于pom.xml文件的路径 --> 
                <directory>src/main/webapp/WEB-INF</directory> 
                <!-- 是否过滤文件，也就是是否启动auto-config的功能 --> 
                <filtering>true</filtering> 
                <!-- 目标路径 --> 
                <targetPath>WEB-INF</targetPath> 
            </resource> 
        </webResources> 
    </configuration> 
</plugin> 
```

#### 4.4 maven-surefire-plugin

打包时候跳过测试。

```java
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <configuration>
        <skip>true</skip>
        <includes>
            <include>**/*Test*.java</include>
        </includes>
    </configuration>
</plugin>

```

#### 4.5 maven-source-plugin

```xml
<!-- 生成sources源码包的插件 -->
<plugin>
    <artifactId>maven-source-plugin</artifactId>
    <version>2.4</version>
    <configuration>
        <attach>true</attach>
    </configuration>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>jar-no-fork</goal>
            </goals>
        </execution>
    </executions>
</plugin>

```

#### 4.6 maven-javadoc-plugin

```xml
<!-- 生成javadoc文档包的插件 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-javadoc-plugin</artifactId>
    <version>2.10.2</version>
    <configuration>
        <aggregate>true</aggregate>
    </configuration>
    <executions>
        <execution>
            <id>attach-javadocs</id>
            <goals>
                <goal>jar</goal>
            </goals>
        </execution>
    </executions>
</plugin>

```

#### 4.7 maven-dependency-plugin

将Maven以来的Jar包复制到一个lib文件夹下，供jar包启动时候实用。

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-dependency-plugin</artifactId>
    <executions>
        <execution>
            <id>copy-dependencies</id>
            <phase>package</phase>
            <goals>
                <goal>copy-dependencies</goal>
            </goals>
            <configuration>
                <type>jar</type>
                <includeTypes>jar</includeTypes>
                <outputDirectory>
                    ${project.build.directory}/lib
                </outputDirectory>
            </configuration>
        </execution>
    </executions>
</plugin>

```

#### 4.8 多个环境

```xml
<properties>
    <env>dev</env>
</properties>
<profiles>
    <profile>
        <id>dev</id>
        <properties>
            <env>dev</env>
        </properties>
        <activation>
            <activeByDefault>true</activeByDefault>
        </activation>
    </profile>
    <profile>
        <id>test</id>
        <properties>
            <env>test</env>
        </properties>
    </profile>
    <profile>
        <id>production</id>
        <properties>
            <env>production</env>
        </properties>
    </profile>
</profiles>

<build>
    <finalName>war_plugin</finalName>
    <resources>
        <resource>
            <directory>src/main/resources</directory>
            <filtering>true</filtering>
        </resource>
    </resources>
    <filters>
        <filter>src/main/filter/${env}/db.properties</filter>
    </filters>
</build>

```

filter根据不同的profile加载相应的properties文件，因此可以在不同的profile下加载不同的配置文件。

默认用dev的配置打包，如果想用production的配置`package -P production`即可加载正式环境的配置。
